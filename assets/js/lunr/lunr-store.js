var store = [{
        "title": "[筆記] 避免 Boxing/Unboxing 效能問題",
        "excerpt":"之前在撰寫 Unity 套件的時候，因為不知道使用者會用什麼類別來傳資料，所以都轉成 object 型別來傳遞，後來發現這會有效能上的問題。本篇文章就來探討這個問題以及解法。 問題 根據官方文件，在 value type（如：int、float 等）與 object type 之間轉換會有效能問題： 如果將一個 value type 轉成 object type 的話，C# 會額外在 heap 建立一個 instance 來儲存 value type 的值。這稱為 boxing。 反之將 object type 轉回 value type 的話，C# 會先檢查該 object 存的值（boxed value）是否可以轉到指定的 value type，然後將值複製回 value type。這稱為 unboxing。 如下圖（參考官方文件繪製）： 再依這篇官方文件，boxing 比直接的 reference 賦值...","categories": ["blog"],
        "tags": ["筆記","Unity","C#"],
        "url": "/blog/2021-12-csharp-boxing-and-unboxing/",
        "teaser": null
      },{
        "title": "[心得] 轉換到嘸蝦米半年心得",
        "excerpt":"在受不了輸入法神奇的選字跟換了沒有方向鍵的 60% 鍵盤的因素下，決定學習新的輸入法，享受不用選字的爽感。在以字形為主的輸入法中，最後選擇嘸蝦米，這篇分享學習方法與使用半年的心得。 為何選擇嘸蝦米 在挑選輸入法時，也有考慮過倉頡跟行列，但最後選擇嘸蝦米的原因是： 聯想直覺：嘸蝦米將字形拆解成字根，而字根以形、音或義與英文字母做連結 不用記鍵盤配置：因為以英文字母做為輸入，所以不用再學鍵盤配置，而且對英打也有幫助 完整學習資源：官網有完整的學習資源，從字根練習、拼字練習、文章測驗，到查字碼應有盡有 幾乎不用選字：即使以字形為主，還是會遇到需要選字的情況，但嘸蝦米需要選字的機會非常小 綜合以上四點，以及因為寫程式，而對英打有一定熟悉度，我覺得嘸蝦米是可以快速上手的輸入法。 簡介嘸蝦米 字根 嘸蝦米將字根以形、音或義與對應的英文字母聯想在一起： 形：取字根的外形，如：「口」→「O」、「冊」→「M」 音：取字根的讀音，如：「大」→「D」、「耳」→「R」 義：取字根對應的英文單字，如：「車」→「Car」→「C」、「斤」→「Kilogram」→「K」 拆字 基本上一個字的拆解原則是：由上而下，由左而右，由外而內，也就是以眼睛看到的順序為主，如下面的例子： 紅色代表形，藍色代表音，綠色代表義。 「部」可以拆為「立」「口」「阝」，所以字碼是「LOB」 「圓」可以拆為「囗」「口」「目」「八」，所以字碼是「OOMB」 「新」可以拆為「立」「木」「斤」，所以字碼是「LTK」 更詳細的拆字原則請參考官網。 大根原則 即盡可能的以最大的字根涵蓋字形。例如「立」雖然可以被拆為「亠」「八」「一」三個字根，但是「立」也是一個字根，所以在上面的「部」字的拆解上不會是「亠」「八」「一」「口」「阝」。 除了基礎字根外，嘸蝦米還有「簡速字根」把基礎字根組合成更大的字根，進而減少要輸入的字碼。 截長補短 「截長」意為當一個字需要四個以上的字根組成時，取前三個加上最後一個做為其字碼： 「優」取前三個「亻」「T」「目」及最後一個「夂」，「冖」「心」省略，所以字碼為「PTMP」 「腳」取前三個「⺼」「八」「八」及最後一個「卩」，「口」省略，所以字碼為「UBBP」 「靈」取前三個「雨」「口」「口」及最後一個「巫」，「口」省略，所以字碼為「UOOW」 「補短」則是當字碼不足三個時，要再補「最後一筆」的根： 加上官網的補根定義： 「方」只有一個字根「方」，需補根，所以字碼為「FY」 「來」只有一個字根「來」，需補根，所以字碼為「LN」 「問」只有兩個字根「門」「口」，需補根，所以字碼為「MOO」 詳細的截長補短原則詳見官網。 一二碼字與簡速字根 這是嘸蝦米為了減少輸入的字碼數而設計的，讓輸入過程更快，算進階版，在學會基礎字根後會比較好理解。 一碼字 雖然只有一個字根的字都要補根成為二碼字，但也有只要一個字碼就可以打出來的字，稱為「一碼字」。小寫數字（一到十，加上○）即為此類，另外還有常用的字組成剩下的 15 個一碼字。如： 「一」的字碼是「E」 「對」的字碼是「A」 「有」的字碼是「X」 二碼字 而二碼字除了因補根而成的之外，還有為了減少輸入字根數而成的，一共 26 乘...","categories": ["blog"],
        "tags": ["心得"],
        "url": "/blog/2021-12-switch-to-boshiamy/",
        "teaser": null
      },{
        "title": "[雜談] 身為工具開發者的二三事",
        "excerpt":"最近終於有機會可以跟到大專案，而專案中有一人負責提供開發工具。為了方便進行 code review，所有成員要使用該工具。但沒有想到才剛使用一週，就遇上開發者大改架構，而且連個事前通知都沒有，一個禮拜的進度化為烏有。崩潰之餘只好來寫一下自己認知中，身為工具開發者時應該要有的觀念。 提供文件 我知道如果工具還在開發中的話，撰寫文件會比較麻煩，因為只要工具一更新，文件就過時了。但是別忘記，可以多利用註解幫忙生成文件，而且只要符合對應的註解格式，IDE 或編輯器也會為工具的 API 加上提示，讓團隊成員能了解函式或變數的用途。工具完成後也可以用 doxygen 等工具生成 API 文件。 例如 C# 可以使用 xml 格式的註解，配合 /// 或是 /** 來撰寫文件註解，而 Visual Studio 就會為函式加上提示 提供範例 範例是說明工具如何使用最有效的手段。每個範例最好只介紹一個功能，配合常見的使用情況，例如：如何發出事件，就用 UI 的按鈕做為例子、如何生成一個物件，就用生成敵人做為例子。除了能夠讓團隊成員容易理解如何使用這個工具，也可以用來驗證自己的設計是否合理，以及測試功能是否正常。 記錄版本與修改 API 更動時常發生，最好能夠用版本來區分改動，並且記錄 changelog。而不是讓團隊成員在合併分支時，才知道工具又更新了，然後伴隨各種崩慣的錯誤訊息。 使用者可以利用版本號確認自己是否使用最新的工具。我習慣 「Major.Minor.Patch」 的格式，只是修正錯誤就增加 Patch 的數字，增加一些功能就增加 Minor 的數字，如果這次的更新會造成使用舊版工具的程式出錯的話，就增加 Major 的數字。要注意的是，對於 Minor 跟 Patch 的版本變更，都應該要相容前面的版本，即不會因更新而報錯。 版本號的簡單說明 而 changelog 應該忠實記錄每個版本做了哪些修改，讓團隊成員能夠知道如何修正程式以跟上最新版本。我覺得 changelog...","categories": ["blog"],
        "tags": ["雜談"],
        "url": "/blog/2022-01-advice-for-tool-developers/",
        "teaser": null
      },{
        "title": "[筆記] C# 類別成員存取關係一覧",
        "excerpt":"本篇用圖表來介紹 C# 類別成員的存取關係，有 private、protected、public，跟跨組件的成員存取，有 internal、protected internal、private protected。以及比較一般繼承與多型繼承中，會取得什麼版本的方法。 類別成員的存取 存取來源 private protected public 自己類別中 :heavy_check_mark: :heavy_check_mark: :heavy_check_mark: 衍生類別中 :x: :heavy_check_mark: :heavy_check_mark: 外部 :x: :x: :heavy_check_mark: 自己類別中 在自己類別中存取的情況是： 在類別定義中，存取類別的成員，如 Test1。 在類別定義中，透過該類別的物件存取成員，如 Test2。 所有 private、protected、public 的成員都可以存取。 public class Bar { private int x; private void Func() { Console.WriteLine(\"Func called\"); } public void Test1()...","categories": ["blog"],
        "tags": ["筆記","C#"],
        "url": "/blog/2022-02-csharp-inheritance-member-accessing/",
        "teaser": null
      },{
        "title": "[影集] Apple TV-基地 Foundation",
        "excerpt":"   在一個由帝國長久統治銀河的時代中，帝國的主星「川陀」上出現了一名數學教授ー哈里．謝頓。他用「心理史學」預測帝國將在未來衰敗，整個銀河會陷入黑暗時期，人們必須建立一個「基地」來保存科技與文化，以在黑暗時期過後，讓銀河文明能快速恢復。   劇情   影集改編自以撒．艾西莫夫（Issac Asimov）的基地系列小說，第一季的劇情從到銀河邊緣「端點星」建立基地，到基地的第一次危機結束之後。基地的團隊從川陀出發後，劇情分為三條路線，同時推移：   本篇圖片及劇照皆取自 Apple TV 網站及其在 YouTube 上的預告片   蓋兒與哈里      蓋兒因其數學的天賦而受邀成為哈里的助手，是最接近哈里的預測模型的人，知道他的預測是正確的，但哈里因「天機不可洩漏」而不願透露其基地計劃的細節與理由。隨著劇情的推移，會逐漸理解到蓋兒受到沉重壓力的痛苦，跟哈里不被諒解的無奈。   帝國      深信帝國永不滅亡的「白晝」皇帝克里昴十二世在聽到哈里的理論後相當生氣，憤而將哈里與其追隨者流放到端點星。但是帝國境內的情勢開始出現變化，發生的事情都跟哈里的預測相符。繼任「白晝」的克里昴十三世為了避免預測成真，開始「導正」事件的發展。但在這過程中，即使是一脈相傳的複製人王朝也會開始出現岐異，開始擔心帝國的存亡。   基地      基地線則圍繞在守護者ー賽佛．哈定身上。在團隊抵達端點星之初就存在非自然造物「穹窿」，穹窿會發出「零場」，無論人類還是生物都無法接近，但只有賽佛可以不受影響。在基地建立不久，就受到臨近星球，為了報復帝國的安納克利安人的入侵，即基地的第一次危機。賽佛肩負起保護基地的責任，傾全力對抗敵人的攻擊。   在第一季的結尾，三條劇情線都作了收束，劇情拋下的每個疑問都有解答，同時也看到他們在未來有不同的發展，為下一季作了起頭。   觀後感   我覺得劇情的剪輯完美的呈現「天機不可洩露」的精隨，所謂要欺騙敵人就得先欺騙自己人，觀眾也是自己人之一。每次看到驚人的一幕時，都想著為什麼要這麼作，或危機來臨時，這樣作是對的嗎？帶著滿滿的不解，直到後面解答時才豁然開朗。因為基地團隊不知道計劃的細節，所以哈里與蓋兒的劇情線就有著解答疑問的角色。      角色中滿喜歡複製人皇帝的設定，同時會有「黎明」、「白晝」、「黃昏」三個皇帝在位，分別是少年、壯年、老年的克里昴，而在黃昏任期到的時候，會變成「黑夜」，最後會直接被雷射安樂死燒成灰，此後新的「黎明」誕生，而其它皇帝則繼承下個位子。老實說，在看黑夜皇帝（克里昴十一世）最後一天在世的告別行程時，心中有股強烈的哀傷，尤其是最後走到雷射光束下的那一段。而劇情中期的白晝皇帝（克里昴十三世），原本以為他完全抱有憐憫心了，但是少女星之後的事，理解到他內心還是流有克里昴的冷血，對他是喜怒參半。最可憐的莫過於克里昴十四世，一出生就是個「錯誤」的存在，完全沒有克里昴的特點，就是一個無邪的少年，但最後的下場令人痛心。原本想說如果克里昴十三世真的打算改變帝國的統治方式，那就有可能「破解」哈里的預言了。      另外星際科幻的一大看點就是對外星文化的想像，從服裝、手勢、器物的設定來呈現那個星球的文化跟環境。安納克利安人的最偉大狩獵者以及用最古老的樹雕成的弓，代表入侵基地的首領菲拉不容小覷。瑟斯皮斯人的藍眼睛跟他們以礦業為主，同是瑟斯皮斯人的雨果也擁有藍眼睛。少女星上的水源有很多鹽份而且純水很珍貴，所以會用鹽晶製成的容器裝水給皇帝代表對他的敬重。   真得滿喜歡影集的改編，看完第一集就覺得這會很對我的胃口，片頭的音樂跟動畫也很棒。雖然有看過原著小說，但是細節忘得差不多了，只記得大致的走向，看完影集之後就想回去重看一次小說。如果有第二季的話，我會滿期待騾的登場。  ","categories": ["blog"],
        "tags": ["影集","觀後感"],
        "url": "/blog/2022-02-foundation-apple-tv-series-reviews/",
        "teaser": null
      },{
        "title": "[筆記] 設定 Android 不要備份 PlayerPrefs",
        "excerpt":"用 Unity 開發 Android 上的遊戲時，如果有用到 PlayerPrefs 儲存使用者的資料，可能會發現在重新安裝後，這些資料還是存在。這是因為在 Android 6.0 以上的版本，Android 都會自動備份應用程式的資料，在重新安裝後會恢復這些資料。 關閉 Android 自動備份資料 如果要關閉 Android 自動備份應用程式的資料，可以在 Unity 的專案中設定。 開啟 Project Settings → Player → Publishing Settings → 勾選 Custom Main Manifest 編輯新增的檔案 Assets/Plugins/Android/AndroidManifest.xml 在 application 標籤中加入 android.allowBackup 屬性，並設為 false 這樣就完成設定了 補充 在 Android Developers 的文件中有註明，如果應用程式跑在 Android 12 以上的版本，則這個選項不會影響手機之間的資料轉存，也就是說 PlayerPrefs...","categories": ["blog"],
        "tags": ["筆記","Unity"],
        "url": "/blog/2022-04-prevent-android-from-backing-up-playerprefs-unity/",
        "teaser": null
      }]
