var store = [{
        "title": "[筆記] 避免 Boxing/Unboxing 效能問題",
        "excerpt":"之前在撰寫 Unity 套件的時候，因為不知道使用者會用什麼類別來傳資料，所以都轉成 object 型別來傳遞，後來發現這會有效能上的問題。本篇文章就來探討這個問題以及解法。 問題 根據官方文件，在 value type（如：int、float 等）與 object type 之間轉換會有效能問題： 如果將一個 value type 轉成 object type 的話，C# 會額外在 heap 建立一個 instance 來儲存 value type 的值。這稱為 boxing。 反之將 object type 轉回 value type 的話，C# 會先檢查該 object 存的值（boxed value）是否可以轉到指定的 value type，然後將值複製回 value type。這稱為 unboxing。 如下圖（參考官方文件繪製）： 再依這篇官方文件，boxing 比直接的 reference 賦值...","categories": ["blog"],
        "tags": ["筆記","Unity","C#"],
        "url": "/blog/2021-12-csharp-boxing-and-unboxing/",
        "teaser": null
      },{
        "title": "[心得] 轉換到嘸蝦米半年心得",
        "excerpt":"在受不了輸入法神奇的選字跟換了沒有方向鍵的 60% 鍵盤的因素下，決定學習新的輸入法，享受不用選字的爽感。在以字形為主的輸入法中，最後選擇嘸蝦米，這篇分享學習方法與使用半年的心得。 為何選擇嘸蝦米 在挑選輸入法時，也有考慮過倉頡跟行列，但最後選擇嘸蝦米的原因是： 聯想直覺：嘸蝦米將字形拆解成字根，而字根以形、音或義與英文字母做連結 不用記鍵盤配置：因為以英文字母做為輸入，所以不用再學鍵盤配置，而且對英打也有幫助 完整學習資源：官網有完整的學習資源，從字根練習、拼字練習、文章測驗，到查字碼應有盡有 幾乎不用選字：即使以字形為主，還是會遇到需要選字的情況，但嘸蝦米需要選字的機會非常小 綜合以上四點，以及因為寫程式，而對英打有一定熟悉度，我覺得嘸蝦米是可以快速上手的輸入法。 簡介嘸蝦米 字根 嘸蝦米將字根以形、音或義與對應的英文字母聯想在一起： 形：取字根的外形，如：「口」→「O」、「冊」→「M」 音：取字根的讀音，如：「大」→「D」、「耳」→「R」 義：取字根對應的英文單字，如：「車」→「Car」→「C」、「斤」→「Kilogram」→「K」 拆字 基本上一個字的拆解原則是：由上而下，由左而右，由外而內，也就是以眼睛看到的順序為主，如下面的例子： 紅色代表形，藍色代表音，綠色代表義。 「部」可以拆為「立」「口」「阝」，所以字碼是「LOB」 「圓」可以拆為「囗」「口」「目」「八」，所以字碼是「OOMB」 「新」可以拆為「立」「木」「斤」，所以字碼是「LTK」 更詳細的拆字原則請參考官網。 大根原則 即盡可能的以最大的字根涵蓋字形。例如「立」雖然可以被拆為「亠」「八」「一」三個字根，但是「立」也是一個字根，所以在上面的「部」字的拆解上不會是「亠」「八」「一」「口」「阝」。 除了基礎字根外，嘸蝦米還有「簡速字根」把基礎字根組合成更大的字根，進而減少要輸入的字碼。 截長補短 「截長」意為當一個字需要四個以上的字根組成時，取前三個加上最後一個做為其字碼： 「優」取前三個「亻」「T」「目」及最後一個「夂」，「冖」「心」省略，所以字碼為「PTMP」 「腳」取前三個「⺼」「八」「八」及最後一個「卩」，「口」省略，所以字碼為「UBBP」 「靈」取前三個「雨」「口」「口」及最後一個「巫」，「口」省略，所以字碼為「UOOW」 「補短」則是當字碼不足三個時，要再補「最後一筆」的根： 加上官網的補根定義： 「方」只有一個字根「方」，需補根，所以字碼為「FY」 「來」只有一個字根「來」，需補根，所以字碼為「LN」 「問」只有兩個字根「門」「口」，需補根，所以字碼為「MOO」 詳細的截長補短原則詳見官網。 一二碼字與簡速字根 這是嘸蝦米為了減少輸入的字碼數而設計的，讓輸入過程更快，算進階版，在學會基礎字根後會比較好理解。 一碼字 雖然只有一個字根的字都要補根成為二碼字，但也有只要一個字碼就可以打出來的字，稱為「一碼字」。小寫數字（一到十，加上○）即為此類，另外還有常用的字組成剩下的 15 個一碼字。如： 「一」的字碼是「E」 「對」的字碼是「A」 「有」的字碼是「X」 二碼字 而二碼字除了因補根而成的之外，還有為了減少輸入字根數而成的，一共 26 乘...","categories": ["blog"],
        "tags": ["心得"],
        "url": "/blog/2021-12-switch-to-boshiamy/",
        "teaser": null
      },{
        "title": "[雜談] 身為工具開發者的二三事",
        "excerpt":"最近終於有機會可以跟到大專案，而專案中有一人負責提供開發工具。為了方便進行 code review，所有成員要使用該工具。但沒有想到才剛使用一週，就遇上開發者大改架構，而且連個事前通知都沒有，一個禮拜的進度化為烏有。崩潰之餘只好來寫一下自己認知中，身為工具開發者時應該要有的觀念。 提供文件 我知道如果工具還在開發中的話，撰寫文件會比較麻煩，因為只要工具一更新，文件就過時了。但是別忘記，可以多利用註解幫忙生成文件，而且只要符合對應的註解格式，IDE 或編輯器也會為工具的 API 加上提示，讓團隊成員能了解函式或變數的用途。工具完成後也可以用 doxygen 等工具生成 API 文件。 例如 C# 可以使用 xml 格式的註解，配合 /// 或是 /** 來撰寫文件註解，而 Visual Studio 就會為函式加上提示 提供範例 範例是說明工具如何使用最有效的手段。每個範例最好只介紹一個功能，配合常見的使用情況，例如：如何發出事件，就用 UI 的按鈕做為例子、如何生成一個物件，就用生成敵人做為例子。除了能夠讓團隊成員容易理解如何使用這個工具，也可以用來驗證自己的設計是否合理，以及測試功能是否正常。 記錄版本與修改 API 更動時常發生，最好能夠用版本來區分改動，並且記錄 changelog。而不是讓團隊成員在合併分支時，才知道工具又更新了，然後伴隨各種崩慣的錯誤訊息。 使用者可以利用版本號確認自己是否使用最新的工具。我習慣 「Major.Minor.Patch」 的格式，只是修正錯誤就增加 Patch 的數字，增加一些功能就增加 Minor 的數字，如果這次的更新會造成使用舊版工具的程式出錯的話，就增加 Major 的數字。要注意的是，對於 Minor 跟 Patch 的版本變更，都應該要相容前面的版本，即不會因更新而報錯。 版本號的簡單說明 而 changelog 應該忠實記錄每個版本做了哪些修改，讓團隊成員能夠知道如何修正程式以跟上最新版本。我覺得 changelog...","categories": ["blog"],
        "tags": ["雜談"],
        "url": "/blog/2022-01-advice-for-tool-developers/",
        "teaser": null
      },{
        "title": "[筆記] C# 類別成員存取關係一覧",
        "excerpt":"本篇用圖表來介紹 C# 類別成員的存取關係，有 private、protected、public。以及比較一般繼承與多型繼承中，會取得什麼版本的方法。 類別成員的存取 存取來源 private protected public 自己類別中 :heavy_check_mark: :heavy_check_mark: :heavy_check_mark: 衍伸類別中 :x: :heavy_check_mark: :heavy_check_mark: 外部 :x: :x: :heavy_check_mark: 自己類別中 在自己類別中存取的情況是： 在類別定義中，存取類別的成員，如 Test1。 在類別定義中，透過該類別的物件存取成員，如 Test2。 所有 private、protected、public 的成員都可以存取。 public class Bar { private int x; private void Func() { Console.WriteLine(\"Func called\"); } public void Test1() { x =...","categories": ["blog"],
        "tags": ["筆記","C#"],
        "url": "/blog/2022-02-csharp-inheritance-member-accessing/",
        "teaser": null
      }]
