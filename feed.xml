<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://lankudot.airfishlab.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lankudot.airfishlab.com/" rel="alternate" type="text/html" /><updated>2025-06-04T23:18:00+08:00</updated><id>https://lankudot.airfishlab.com/feed.xml</id><title type="html">烏龜漫遊 2.0</title><subtitle>記錄分享在 Unity 上製作遊戲的筆記與心得</subtitle><author><name>烏龜</name></author><entry><title type="html">[開發日誌 #2] A 需要跑步但 B 只要走路</title><link href="https://lankudot.airfishlab.com/blog/2025-06-refactor-general-module/" rel="alternate" type="text/html" title="[開發日誌 #2] A 需要跑步但 B 只要走路" /><published>2025-06-04T00:00:00+08:00</published><updated>2025-06-04T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/refactor-general-module</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2025-06-refactor-general-module/"><![CDATA[<p>在這次開發的遊戲中，角色有不同的移動方式，像是玩家角色會以方向做為移動輸入，而敵人角色則是以路徑做為移動目標，而這兩者又有以距離為主的移動方式，如：瞬步、攻擊墊步。所以一開始做了通用的移動模組來整合這些方式，讓所有角色使用。但隨著敵人角色的移動方式增加，為了讓模組能保持「通用」，部份功能只能做在模組之外，造成移動方式無法集中管理。最後受不了重新設計移動模組一番，讓模組能夠為不同的角色提供各自需要的功能，又可以保持增加移動方式的彈性。</p>

<h2 id="通用模組的問題">通用模組的問題</h2>

<p>一開始通用模組設計如下圖：</p>

<p><img src="/assets/images/blog/2025/2025-06-04-refactor-general-module/original-design-uml.svg" alt="original-design-uml" /></p>

<ul>
  <li>通用移動模組 <code class="language-plaintext highlighter-rouge">CharacterMovementModule</code> 中提供不同的移動方式的子模組：
    <ul>
      <li>靜止的 <code class="language-plaintext highlighter-rouge">IdleMovement</code></li>
      <li>以速度向量為主的 <code class="language-plaintext highlighter-rouge">VelocityMovement</code></li>
      <li>以距離為主的 <code class="language-plaintext highlighter-rouge">DashMovement</code></li>
      <li>以路徑為主的 <code class="language-plaintext highlighter-rouge">PathMovement</code></li>
    </ul>
  </li>
  <li>移動模組同時只會有一個子模組在執行，當子模組執行結束後（如：移動路徑走完了），會自動轉到 <code class="language-plaintext highlighter-rouge">IdleMovement</code></li>
  <li>尋路用的模組 <code class="language-plaintext highlighter-rouge">PathFindingModule</code></li>
</ul>

<h3 id="提供用不到的功能">提供用不到的功能</h3>

<p>這是遊戲中各類角色需要的移動功能：</p>

<table>
  <thead>
    <tr>
      <th>移動方式</th>
      <th>玩家角色</th>
      <th>敵人角色</th>
      <th>NPC</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>靜止</td>
      <td>:heavy_check_mark:</td>
      <td>:heavy_check_mark:</td>
      <td>:heavy_check_mark:</td>
    </tr>
    <tr>
      <td>速度向量</td>
      <td>:heavy_check_mark:</td>
      <td>:x:</td>
      <td>:x:</td>
    </tr>
    <tr>
      <td>距離</td>
      <td>:heavy_check_mark:</td>
      <td>:heavy_check_mark:</td>
      <td>:x:</td>
    </tr>
    <tr>
      <td>路徑</td>
      <td>:heavy_check_mark:（路徑更新一次）</td>
      <td>:heavy_check_mark:（路徑定期更新）</td>
      <td>:heavy_check_mark:（一次跟定期更新都要）</td>
    </tr>
  </tbody>
</table>

<p>設計成通用模組的問題是，使用的角色會有用不到的功能。敵人角色用不到速度向量的移動功能，而 NPC 一樣用不到速度向量的移動功能之外，也用不到距離為主的移動功能。</p>

<h3 id="不易擴充">不易擴充</h3>

<p>另外從上面的表可以看到，以路徑移動的形式有兩種：只要更新一次路徑（移動到指定位置）跟定期更新路徑（持續追隨）。為了讓移動模組能「通用」，所以只提供傳入路徑再移動的功能。這時玩家角色需要實作讓尋路模組來找路徑後傳入移動模組的功能，而敵人角色則需要實作定期更新路徑的功能，然而 NPC 卻兩種形式都要，所以就得要再各實作一次一樣的功能。雖然可以把這兩種路徑移動形式連同尋路模組一起整合到移動模組內，但這樣移動模組就會相依於尋路模組，而且爾後有需要其它模組的移動方式的話，都會讓移動模組相依更多模組。如果有新的角色是不需要路徑移動方式的話，為了移動模組還要再生成尋路模組就顯得多餘了。</p>

<p><img src="/assets/images/blog/2025/2025-06-04-refactor-general-module/original-design-coupling.svg" alt="original-design-coupling" />
<em>讓模組相依於其它模組的問題是無論用不用的到對應的模組，都得要生成依賴的模組</em></p>

<h2 id="重構版本">重構版本</h2>

<p>這是重構後的版本：</p>

<p><img src="/assets/images/blog/2025/2025-06-04-refactor-general-module/refactor-design-player-uml.svg" alt="refactor-design-player-uml" /></p>

<ul>
  <li>移動方式各自獨立成外部子模組，繼承自 <code class="language-plaintext highlighter-rouge">IMovement</code>，並自行提供所需要的建構子與初始化函式</li>
  <li><code class="language-plaintext highlighter-rouge">CharacterMovementModule</code> 只保留移動方式切換的功能，透過 <code class="language-plaintext highlighter-rouge">IMovment</code> 介面存取移動方式子模組</li>
  <li>角色需要實作自己所需的移動模組，像玩家要實作 <code class="language-plaintext highlighter-rouge">PlayerMovementModule</code>，在裡面建立與初始化所需的移動方式子模組，並註冊給 <code class="language-plaintext highlighter-rouge">CharacterMovementModule</code> 管理</li>
  <li>角色自己的移動模組也會存建立的移動方式子模組，在需要切換移動方式時，先設置好參數，再切換移動方式</li>
</ul>

<p>如此一來，通用移動模組就不用依賴其它模組了，而是由角色自己的移動模組傳入需要的模組。另外移動方式獨立成子模組後，就可以像積木一樣，由角色自己的移動模組拼出所需要的移動功能。如敵人與 NPC 的移動模組會像這樣：</p>

<p><img src="/assets/images/blog/2025/2025-06-04-refactor-general-module/refactor-design-enemy-uml.svg" alt="refactor-design-enemy-uml" />
<img src="/assets/images/blog/2025/2025-06-04-refactor-general-module/refactor-design-npc-uml.svg" alt="refactor-design-npc-uml" /></p>

<p>另外兩種不同的路徑移動方式也分成路徑走一次的 <code class="language-plaintext highlighter-rouge">PathMovement</code> 與路徑定期更新的 <code class="language-plaintext highlighter-rouge">FollowMovement</code>，而這兩個移動方式的共同邏輯則是取出做成一個 <code class="language-plaintext highlighter-rouge">PathHelper</code> 來幫助執行路徑移動。</p>

<h2 id="總結">總結</h2>

<p>使用情境差不多的話，做成通用模組是合適的方法，而且一開始規格還不明確的時候，太早設計成這樣也可能殺雞用牛刀。但當出現一些清況，就得要開始思考這樣做適不適合了，像是：</p>

<ul>
  <li>有部份功能只是為了某些使用者存在</li>
  <li>模組是不是開始相依其它模組的功能</li>
  <li>每次加入新功能時，模組邏輯是否得要大幅修改</li>
  <li>為了配合新功能，其它使用者是否也要改變使用方式</li>
</ul>

<p>如果有這樣的情況就得要考慮重構了。</p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="開發日誌" /><summary type="html"><![CDATA[在這次開發的遊戲中，角色有不同的移動方式，像是玩家角色會以方向做為移動輸入，而敵人角色則是以路徑做為移動目標，而這兩者又有以距離為主的移動方式，如：瞬步、攻擊墊步。所以一開始做了通用的移動模組來整合這些方式，讓所有角色使用。但隨著敵人角色的移動方式增加，為了讓模組能保持「通用」，部份功能只能做在模組之外，造成移動方式無法集中管理。最後受不了重新設計移動模組一番，讓模組能夠為不同的角色提供各自需要的功能，又可以保持增加移動方式的彈性。]]></summary></entry><entry><title type="html">[開發日誌 #1] 狀態機奮鬥記</title><link href="https://lankudot.airfishlab.com/blog/2025-05-fight-with-state-machine/" rel="alternate" type="text/html" title="[開發日誌 #1] 狀態機奮鬥記" /><published>2025-05-08T00:00:00+08:00</published><updated>2025-05-08T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/fight-with-state-machine</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2025-05-fight-with-state-machine/"><![CDATA[<p>時光荏苒，參與新專案到現在也超過半年了。因為是第一次做動作遊戲，面對沒開發過的機制，看了許多資料，也踩了不少的坑，就覺得應該來寫個開發日誌，多少記錄一下開發過程的酸甜苦辣鹹。開張第一篇先來分享開發狀態機時的碰壁。</p>

<blockquote>
  <p>成功的經驗很棒，但失敗的經驗也值得參考啊</p>
</blockquote>

<p>在新專案之前，沒想到都沒有開發過狀態機，就算有需要狀態的地方，也因為是線性流程，所以不需要用狀態機。但在動作遊戲中，狀態機是遊戲的核心，角色要狀態機，關卡流程也要狀態機，然後狀態機裡面也可能要有自己的狀態機。</p>

<h2 id="狀態轉換機">狀態（轉換）機</h2>

<p>雖然知道通常會在狀態機中執行角色的行為，但是一開始功能單純，就設計成讓狀態機專責處理狀態轉換的判斷，而狀態的執行還是在角色中：</p>

<p><img src="/assets/images/blog/2025/2025-05-08-fight-with-state-machine/bad-state-machine.svg" alt="bad-state-machine" /></p>

<p>角色會提供角色狀態（status）給狀態機判斷，狀態機中對每個狀態（state）提供不同的判斷函式，在角色中則是提供不同的執行函式。當狀態機判斷要切換狀態後，會通知角色也切換執行函式，角色執行函式就會更新角色狀態。</p>

<p>但當狀態開始變多與功能變複雜時，這樣的設計出現了兩個問題。第一個問題是因為狀態（state）要用到的狀態（status）都是由角色提供與更新，所以就算那個變數只是為了給某個狀態使用（像是控制一個狀態執行多久的計時器），也要宣告在角色上，造成那個變數有機會被其它狀態更新到：</p>

<p><img src="/assets/images/blog/2025/2025-05-08-fight-with-state-machine/bad-state-machine-variable-problem.svg" alt="bad-state-machine-variable-problem" /></p>

<p>另外這些類變數一多起來，管理上也不方便。</p>

<p>第二個問題是如果狀態中要額外做其它事會變得相當麻煩。由於判斷都是交由狀態機執行，所以狀態機判斷要做額外的事情時（像是在攻擊狀態中被打時，不轉換成硬直狀態，而是只改變一點位移），得要另外傳資料出來，因為原本狀態機回傳的資料是告知狀態轉換的資訊：</p>

<p><img src="/assets/images/blog/2025/2025-05-08-fight-with-state-machine/bad-state-machine-sub-operation-problem.svg" alt="bad-state-machine-sub-operation-problem" /></p>

<p>再者，用來傳遞額外資訊的物件，可能會因為每個狀態需要做不同的額外事情，而讓變數越來越多，出現與第一個問題同樣的情況。</p>

<h2 id="繞了遠路">繞了遠路</h2>

<p>為了解決這個有問題的狀態機，就開始想：</p>

<ul>
  <li>為什麼不讓狀態判斷函式變成類別，讓它自己管理需要的變數就好？</li>
  <li>為什麼不讓狀態執行函式自己判斷需要額外做的事情就好？</li>
</ul>

<p>然後就想到：<strong>為什麼不直接把狀態自己的判斷跟執行函式都放在同一個類別就好？</strong></p>

<p>唉呀，繞了一圈，結果還是做最典型的狀態機就好了啊：</p>

<p><img src="/assets/images/blog/2025/2025-05-08-fight-with-state-machine/state-machine-redesign.svg" alt="state-machine-redesign" /></p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="開發日誌" /><summary type="html"><![CDATA[時光荏苒，參與新專案到現在也超過半年了。因為是第一次做動作遊戲，面對沒開發過的機制，看了許多資料，也踩了不少的坑，就覺得應該來寫個開發日誌，多少記錄一下開發過程的酸甜苦辣鹹。開張第一篇先來分享開發狀態機時的碰壁。]]></summary></entry><entry><title type="html">[遊記] 2025 F1 日本大獎賽 - 行程準備</title><link href="https://lankudot.airfishlab.com/blog/2025-05-f1-japan-grand-prix-trip-planning/" rel="alternate" type="text/html" title="[遊記] 2025 F1 日本大獎賽 - 行程準備" /><published>2025-05-03T00:00:00+08:00</published><updated>2025-05-03T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/f1-japan-grand-prix-trip-planning</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2025-05-f1-japan-grand-prix-trip-planning/"><![CDATA[<p>自 2020 年入坑以來，看 F1 也進入第 6 年了。大概從前年萌生到現場看比賽的念頭，也看了一些現場觀賽的分享文後，毅然決然選定了今年的日本大獎賽。選擇日本場的原因除了日本旅遊環境友善之外，比賽舉辦的時間剛好落在清明連假，賽道當地的鈴鹿與鄰近的名古屋也是櫻花季的時期，因此這趟現地之旅就成行了。受惠於前人的分享文，所以這篇文章也來分享如何規劃行程。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/suzuka-circuit-gp-entrance.png" alt="suzuka-circuit-gp-entrance" /></p>

<h2 id="門票">門票</h2>

<p>通常在比賽舉辦日的半年前開始售票，像今年日本大獎賽辦在 4 月初，去年 10 月中開放購票。所以在去年公布今年的賽曆之後，就開始關注售票的資訊了。購買 F1 日本大獎賽門票的管道有兩個：<a href="https://tickets.formula1.com/en" target="_blank">F1 官網</a>與賽道方使用的 <a href="https://ticket.mobilitystation.jp/" target="_blank">Mobility Station</a>，雖然 F1 官網會比賽道方還要早開放售票，但是只能選區域不能選座位，而且價格也貴上許多。而賽道官網則是有限制可以購買的國家，但今年台灣可以從賽道官網購票，此外還可以選擇位置，所以我這次是透過賽道官網購票。</p>

<p>在開放售票前就可以先研究要買哪一區，在<a href="https://www.suzukacircuit.jp/zh-tw/course_s/" target="_blank">賽道官網</a>上可以看到每一區的視野與影片。位置選擇的話可以考量：</p>

<ul>
  <li>視野好不好：能看到賽車經過的時間有多久，另外下層座位可能被護欄和鐵網擋到</li>
  <li>能不能看到螢幕：鈴鹿賽道一圈約 1 分半，大約有 1 分鐘沒有賽車經過，所以能看到螢幕的話，就可以知道其它地方發生了什麼事，上面也有即時的排名與秒差。在賽道官網的視野地圖上也有標出螢幕的設置位置</li>
  <li>超車熱點：比賽最刺激的就是看超車攻防，通常會發生在 DRS 區的尾端</li>
</ul>

<p>我偏向超車熱點，以鈴鹿賽道來說就是大直線的尾端的 A2 區或是第 1, 2 彎的 B2 區，比賽大部份的超車都發生在這裡，也是起跑後的第一個攻防點。此外這兩個區可以完整看到賽車入彎到出彎，另外鈴鹿賽道的第 1 彎的入彎速度也很快，可以體驗到速度感。而 A2 區還可以看到賽車出 pit lane，當然這兩區的價格上也不便宜。如果有預算上的限制，在選擇上可以以能不能看到螢幕為優先選擇。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/a2-zone-in-map.png" alt="a2-zone-in-map" />
<em>F1 舉行時會增設看臺，A2 區就是其中之一</em></p>

<p>在門票開賣那天，理所當然會湧入大量購票者，Mobility Station 也會有流量管制。但進入排隊也不用覺得沒希望，而且也可能提前進入購買頁面（顯示 90 分鐘以上等待，但沒多久就進入頁面了），所以要時時留意排隊狀況。然而如果一開始瞄準的是熱門區域的話，最好要有備案。我這次排了 1 小時之後，B2 區售罄，但 A2 區還是有很多位置可以選，最後就選了 A2 區後排，也可以看到螢幕的位置。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/a2-zone-view-1.png" alt="a2-zone-view-1" />
<img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/a2-zone-view-2.png" alt="a2-zone-view-2" />
<em>A2 區的視野，可以看到 pit 出口以及第 1, 2 彎，這邊也是超車熱點</em></p>

<p>使用 Mobility Station 購買門票會是電子票券，當天進場就直接用票券顯示的 QR Code 即可，在比賽日進入座位區也要再出示座位資訊，如果不放心也可以印出來備用。</p>

<h2 id="行程安排">行程安排</h2>

<p>F1 日本站賽程一樣為期三天，週五的練習，週六的練習與排位賽，跟週日的重頭戲正賽。另外，鈴鹿賽道在週四早上 9 點到 12 點還有開放參觀賽道的起點大直線與 pit lane，可以走在賽道上及看到車隊在車庫整備，是不容錯過的機會，所以可以從週四開始安排行程。而鈴鹿賽道鄰近名古屋，在沒有看比賽的時間也可以在名古屋旅遊。我這次的行程安排是這樣：</p>

<table>
  <thead>
    <tr>
      <th>日期</th>
      <th>行程</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4/2 (三)</td>
      <td>中午抵達日本</td>
    </tr>
    <tr>
      <td>4/3 (四)</td>
      <td>早上參加賽道日、下午回名古屋</td>
    </tr>
    <tr>
      <td>4/4 (五)</td>
      <td>名古屋</td>
    </tr>
    <tr>
      <td>4/5 (六)</td>
      <td>鈴鹿賽道</td>
    </tr>
    <tr>
      <td>4/6 (日)</td>
      <td>鈴鹿賽道</td>
    </tr>
    <tr>
      <td>4/7 (一)</td>
      <td>中午回台灣</td>
    </tr>
  </tbody>
</table>

<p>基本上到了賽道後，就會整天待在那邊，所以除了觀看 F1 之外，還可以安排其它活動。像是同期間也會有其它賽事，這次有保時捷卡雷拉盃（Porsche Carrera Cup）跟法拉利挑戰賽（Ferrari Challenge）的賽程，可以體驗不同賽車車種的音浪。戶外廣場有車手週邊與活動攤位，主舞臺也有車手訪談與知識分享，在官方網站中都會公佈相關時間表，可以在比賽間隔前去聆聽。此外鈴鹿賽道裡還有遊樂園與本田博物館，遊樂園的摩天輪可以飽覽整個賽道，博物館則有展出許多經典的 F1 賽車。不過主舞臺、遊樂園、博物館都在離在正門比較近的區域，如果觀賽座位在比較遠的地方，可以在進場之後，先去逛這些地方，下午再到座位上觀賽。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/ferris-wheel.png" alt="ferris-wheel" />
<img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/view-from-ferris-wheel.png" alt="view-from-ferris-wheel" />
<em>摩天輪一圈約 15 分鐘，可以一覽整個園區</em></p>

<p>非常推薦在週四就到賽道，除了賽道日活動之外，因為人潮不多，遊樂園或是活動攤位很好排，是體驗這些設施的好時間。另外這天就可以購買車手與賽道的週邊，除了商品充足之外，一樣也不太需要排隊，比賽日也不需要大包小包。而且這天的座位區不用驗票，所以也可以去看看在大直道的座位體驗是什麼感覺。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/v-zone-view.png" alt="v-zone-view" />
<em>在賽道日去了 V 區坐了一下，可以看到 pit 的工作情況</em></p>

<h2 id="機票與飯店">機票與飯店</h2>

<p>因為是清明連假期間，所以即使是廉航，票價一樣不便宜。像這次是搭虎航，來回就要 2 萬 4，後續關注價格也越來越貴，但說不定其實後來有促消特價，只是考慮到連假機票比較搶手，所以在一開賣就購買機票了。不過如果可以提前幾天出發或是晚幾天回來的話，機票價格就可以少掉一半。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/window-view-from-airplane.png" alt="window-view-from-airplane" />
<em>一直很想坐窗邊的位子，這次終於圓夢了</em></p>

<p>至於飯店的部份，地點首選是名古屋。除了方便抵達賽道之外，週圍行程也很好安排，另外晚上從賽道回來也還有地方可以吃晚餐。我這次是住在榮附近的飯店，搭地鐵到名古屋站不到 10 分鐘，而且榮地鐵站也是重要節點，搭乘到其它地方也相當方便。</p>

<p>然而因為會有十幾萬人來參加 F1 賽事，所以飯店也是非常搶手，另外價格也會比平常高。這次在訂完 F1 門票之後才開始找飯店，但發現交通比較方便又價格可以接受的選擇不多了。建議可以提前找能夠退訂的飯店，選擇應該會比較多，而且到時沒有搶到 F1 門票的話，也可以再退訂就好。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/nagoya-prime-central-tower.png" alt="nagoya-prime-central-tower" />
<em>中部電力塔就在住宿飯店附近</em></p>

<h2 id="交通">交通</h2>

<p>到賽道可以選擇自駕或是搭乘大眾交通工具，而我只能選擇大眾交通。從名古屋到賽道有兩個選擇，一個是從名古屋站搭乘近鐵線到白子車站，再轉搭接駁車到賽道，是我這次的搭乘方式；另一個是從名古屋站搭 JR 線到四日市站，再轉乘伊勢鐵道到鈴鹿稻生站，最後走路到賽道。這兩個的差別主要是前者可以不用走太多路，也不用轉乘，而後者則是可以從一號彎門入場，不過也可以再走到正門入場。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/train-and-bus-access-information.png" alt="train-and-bus-access-information" /></p>

<p>搭乘近鐵可以事先在近鐵的<a href="https://www.ticket.kintetsu.co.jp/vs/en/T/TZZ/TZZ10.do?op=tDisplayVisitorMenu">官方網站</a>上預訂特急的車票，搭乘特急的好處是有位子坐之外，停的車站也比較少，特急約 40 分鐘，而急行則是要 1 小時。近鐵的特急車票是由普通車票與特急乘車券兩張車票構成，可以想成一張是基本費用，另一張則是升等特急車廂的車票。從名古屋到白子的費用是基本車資 1000 日元加上特急車資 920 日元。而能在官網預訂的只有特急乘車券，而且只提供電子證明（沒有 QR Code，也不能領實體票），所以預訂完成後要將座位資訊擷圖下來供查票用，但進站時不用特別出示。普通車票則是在進站時刷 IC 卡或是在車站購買車票，但不建議用電子車票，因為現場出站人潮多，然而 QR Code 掃描機數量不多，很容易塞住。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/shiroko-station.png" alt="shiroko-station" />
<em>白子車站前圓環的歡迎布條</em></p>

<p>到白子車站後，跟著人群走就會到接駁車的等待隊伍。我分別在週六 9 點與週日 8 點抵達車站，排隊隊伍算順暢，大約 15 ~ 20 分鐘後上接駁車，車程約 30 分鐘。接駁車車資 500 日元，是在接駁車下車處支付，可以用 IC 卡也可以付現，所以不用在上車時付錢。而下車處是在賽道外的停車場，所以還要再走 20 分鐘才會到正門。不過週四的接駁車不太一樣，因為非比賽日，所以班次比較少，雖然人也不多，但是我剛好遇到沒班的時間，等了 1 小時多才搭到，不過下車處在正門口，另外是在乘車處支付票錢。</p>

<p>這次去程的時間是這樣：</p>

<table>
  <thead>
    <tr>
      <th>時間</th>
      <th>名古屋出發</th>
      <th>白子抵達</th>
      <th>接駁車上車</th>
      <th>抵達賽道正門</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>週四</td>
      <td>(四日市出發，急行)</td>
      <td>9:20</td>
      <td>10:35</td>
      <td>11:10</td>
    </tr>
    <tr>
      <td>週六</td>
      <td>8:10</td>
      <td>8:49</td>
      <td>9:10</td>
      <td>10:00</td>
    </tr>
    <tr>
      <td>週日</td>
      <td>7:30</td>
      <td>8:09</td>
      <td>8:30</td>
      <td>9:20</td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/ticket-booth.png" alt="ticket-booth" />
<em>接駁車下車處的付錢處，左邊是付現買票，右邊則是刷 IC 卡</em></p>

<p>當然越晚出發人潮越多，等待時間就越久。為了避免花太多時間在排隊上，比較建議比賽日早上 7 點到白子車站，早一點到賽道就可以好好逛逛，而且在主舞臺週五週六兩天的車手訪談分別是在 10 點跟 9 點半開始，晚到就錯過了。而週四賽道日則建議 8 點到白子車站，因為賽道與 pit lane 參觀的開放時間只到中午 12 點，我這次 11 點到賽道差點來不及。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/saturday-morning-crowd.png" alt="saturday-morning-crowd" />
<em>早上入場還算順暢，但是場內的攤位已經需要排隊了</em></p>

<p>至於從賽道的回程，因為沒辦法預估什麼時候能到車站，所以沒有預訂特急車票，而是到車站後搭急行（不要選到普通車，等同於台灣的區間車，會站站停）。比賽日離場的人很多，因此等待接駁車的時間會很久。我這次買在 A2 席，所以可以在排位賽跟正賽結束的時候，早一點到接駁車的乘車處，但週日還是等了 1 小時多，想當然如果更晚離開就得要等更久，我在比賽日這兩天還可以回到名古屋吃晚餐。至於週四賽道日則是在正門搭乘接駁車，人不多也不用等待，只是下午 1 點才有回程的接駁車。</p>

<p>回程的時間是這樣：</p>

<table>
  <thead>
    <tr>
      <th>時間</th>
      <th>離場</th>
      <th>抵達乘車處</th>
      <th>接駁車上車</th>
      <th>抵達白子</th>
      <th>上火車</th>
      <th>抵達名古屋</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>週六</td>
      <td>16:00</td>
      <td>16:25</td>
      <td>16:50</td>
      <td>17:10</td>
      <td>17:28</td>
      <td>18:23</td>
    </tr>
    <tr>
      <td>週日</td>
      <td>15:40</td>
      <td>16:15</td>
      <td>17:30</td>
      <td>17:50</td>
      <td>18:14</td>
      <td>19:10</td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/returning-crowd.png" alt="returning-crowd" />
<img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/waiting-line.png" alt="waiting-line" />
<em>比賽日回程的人潮很恐怖，聽說有些人不想等車，直接徒步回白子車站</em></p>

<h2 id="飲食">飲食</h2>

<p>賽道園區內會有賣食物與飲料的攤販，只是價格會比較高，而且品質不穩定。可以事先採買好午餐、零食、飲料，再帶到園區內，現場也不時可以看到有人提著一袋食物入場。但如果想要吃點鹹的熱的，還是可以到攤販區逛一下，只是要找到好吃的得碰運氣。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/normal-bentou.png" alt="normal-bentou" />
<em>因為嘴饞買了這個 1200 日元的便當，但不好吃QQ</em></p>

<h2 id="總結">總結</h2>

<p>這篇文章除了記錄這次的行程規劃之外，如果之後要再次衝現地的話，也可以作為改善行程的參考，也希望這篇文章能幫助到有需要的人。這趟旅程也是做好行前準備，才能在比賽週好好體驗賽道慶典，留下很棒的回憶。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/sakura.png" alt="sakura" />
<em>賽道也種植許多櫻花，看比賽與看櫻花一次滿足</em></p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="遊記" /><summary type="html"><![CDATA[自 2020 年入坑以來，看 F1 也進入第 6 年了。大概從前年萌生到現場看比賽的念頭，也看了一些現場觀賽的分享文後，毅然決然選定了今年的日本大獎賽。選擇日本場的原因除了日本旅遊環境友善之外，比賽舉辦的時間剛好落在清明連假，賽道當地的鈴鹿與鄰近的名古屋也是櫻花季的時期，因此這趟現地之旅就成行了。受惠於前人的分享文，所以這篇文章也來分享如何規劃行程。]]></summary></entry><entry><title type="html">[電影] 2024 看過的那些電影們</title><link href="https://lankudot.airfishlab.com/blog/2025-03-watched-movies-in-2024/" rel="alternate" type="text/html" title="[電影] 2024 看過的那些電影們" /><published>2025-03-30T00:00:00+08:00</published><updated>2025-03-30T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/watched-movies-in-2024</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2025-03-watched-movies-in-2024/"><![CDATA[<p>去年因為工作變得比較繁重，所以電影看的不多，不過這樣反而可以寫得比較詳細。為了篇幅，就簡單分成真人電影與動畫電影兩篇，這篇就記錄真人電影的部份。去年最喜歡的電影就是《沙丘：第二部》了，去二刷的時候還選了 IMAX 的版本，對於太空科幻的題材真的愛不釋手啊。</p>

<h2 id="沙丘第二部">沙丘：第二部</h2>

<p><img src="/assets/images/blog/2025/2025-03-30-watched-movies-in-2024/dune-part-2-poster.png" alt="dune-part-2-poster" /></p>

<p>被哈肯能家族襲擊，失去駐地與家人的保羅．亞崔迪加入史帝加帶領的弗瑞曼人部族後，開始集結弗瑞曼人組織對抗哈肯能家族的行動。同時保羅的母親潔西嘉女士，也利用貝尼．潔瑟睿德姐妹會事先散佈的預言以及弗瑞曼人的信仰，將保羅塑造成救世主，以獲取弗瑞曼人的支持。而哈肯能家族在奪回厄拉科斯的主導權後，繼續以往的香料採收事業，但弗瑞曼人則利用遊擊戰術破壞哈肯能人的設備以干擾採收。哈肯能男派出心狠手辣的侄子菲得．羅薩，前往厄拉科斯剷除弗瑞曼人。</p>

<p>我很喜歡太空科幻中，用宗教、文化、儀式、服裝來帶出一個種族或勢力的個性與特色。像是哈肯能家族的母星羯地主星上，人民都是光頭，穿著黑色長袍，也有著獨特的歡呼手勢。為了慶祝菲得的生日，則是在鬥技場中讓他獵殺三名亞崔迪家的俘虜。再再顯示哈肯能家是邪惡的好戰勢力。不過菲得登場的這場戲，也是我喜歡的片段之一，為了還原羯地主星所在的星系的太陽是發出紅外線光，導演特別用紅外線攝影機來拍攝，讓畫面呈現都是黑白色的。相比 1984 年《沙丘魔堡》電影裡的菲得是瘋瘋巔巔的殺手，這版的菲得顯得冷酷多謀，很有反派魅力。</p>

<p>保羅與菲德的一對一最終決戰也相當精彩，沒有過份的晃動鏡頭，可以很清楚地理解發生了什麼事。看了幕後花絮知道他們都為了戲中的打鬥練習了很多，也才知道在鬥技場跟菲得打到最後的那名演員就是本片的武術指導。當然最終保羅贏得勝利，在獲得漠大的權力後，準備向宇宙的氏族宣戰，然而此舉讓卻保羅的心上人荃妮感到生氣又失望，同時保羅夢到的聖戰已經被觸發。</p>

<h2 id="gt跨界玩家">GT：跨界玩家</h2>

<p><img src="/assets/images/blog/2025/2025-03-30-watched-movies-in-2024/gran-turismo-poster.png" alt="gran-turismo-poster" /></p>

<p>《GT：跨界玩家》是真人真事改編的電影，主角揚從小就迷上《Gran Turismo》，並且夢想成為一名職業賽車手。有一天在遊戲賽道上創下的最佳記錄，讓他獲得參加由 Nissan 與遊戲開發商共同舉辦的「GT 學院」的機會。這個學院聚集了 8 位頂尖玩家，並把他們培養成職業賽車手，最後篩選出 1 位來參加他們的車隊。這對於一直被家人反對玩遊戲的揚來說，無疑是可以證明自己的機會。</p>

<p>雖然這類電影可以知道主角的結果，但是過程怎麼發展才是電影的重點，與家人的衝突、訓練的艱苦、被職業選手看輕，一再地為主角的成功加上更多的份量，也知道這結果得來不易。電影的賽車畫面也都是實車實地拍攝，就為了給觀眾最真實的比賽體驗，而故事的真人揚也在電影中擔任特技替身。比較可惜的是賽車中的畫面不夠長，經常在人物跟賽車間切換，看得不夠過癮。《Gran Turismo》也是我第一款接觸的賽車遊戲，所以得知這部電影時，就一直有興趣。但上映那時沒有時間到電影院觀看這部電影，直到在 Netflix 上架，才有機會補完，看完覺得如果當初能到電影院體驗引擎的轟隆聲，那感覺一定很棒。</p>

<h2 id="秘境探險">秘境探險</h2>

<p><img src="/assets/images/blog/2025/2025-03-30-watched-movies-in-2024/uncharted-poster.png" alt="uncharted-poster" /></p>

<p>《秘境探險》是同名遊戲的改編電影，主角奈森流著探險家的血液，原本在酒吧擔任酒保的他，遇到寶藏獵人蘇利文告訴他正在尋找埋藏的黃金，而原本的合伙人就是奈森的哥哥ー山姆。山姆在奈森小時候，為了不想被因為多次闖入博物館偷東西被關而逃離孤兒院，雖然當時約好會回來找奈森，但是這個承諾一直沒有兌現。做為幫助蘇利文，同時為了尋找哥哥山姆的下落，奈森踏上這趟尋寶旅程。</p>

<p>做為尋寶冒險電影，肯定少不了謎題、陷阱、覬覦同個寶藏的壞人與同夥的背叛。只是可惜的是，覺得這部電影對這些要素只是把它放進去，但沒有加深刻劃。劇情的走向可以猜得到，但也沒有意外的發展。像是敵人可以找到最後的埋藏點，只是因為剛好看到主角開船往那個方向移動，雖然可以合理解釋為什麼敵人可以到達那邊，但就是選了個最普通的原因。最驚喜的反而是彩蛋，像是遊戲制作公司頑皮狗的貼紙、遊戲中奈森的真人演員諾蘭也有參一腳。另外就是當主角奈森無意戴上腋下槍套背帶，成為遊戲中的造型時，更是令人興奮。</p>

<h2 id="小丑雙重瘋狂">小丑：雙重瘋狂</h2>

<p><img src="/assets/images/blog/2025/2025-03-30-watched-movies-in-2024/joker-2-poster.png" alt="joker-2-poster" /></p>

<p>原本以為作為《小丑》的續作，再加上「雙重瘋狂」的副標題，覺得這次應該是要開始讓高譚市瘋狂了，然而整部電影就只有「亞瑟」沒有「小丑」。每當你以為亞瑟要開始瘋狂、情緒要爆發的時候，亞瑟就退縮了，說其實自己沒有想要成為小丑，電影看完只留下壓抑的感受。</p>

<p>不過滿喜歡電影前半的部份，使用歌舞做為小丑的內心幻想或是情緒延續。歌曲用在美國脫口秀中由 house band 演奏的那類爵士樂，搭配戲謔的歌詞，以及一直在背景的不協調單音。雖然充滿脫口秀的那種戲謔歡樂氣氛，但不協調的單音也帶著壓抑感，彷彿說著這一切只不過是個「Joke」。但是這種穿插歌舞表演的形式到了後半反而變成一種濫用，一到需要表達內心情感的時候，就開始唱歌，反而相當破壞節奏，甚至覺得有點煩燥。不知道是不是為了配合 Lady Gaga，才用歌舞表演的形式呈現。只是具體地把情感用歌詞唱出來，反而覺得有點多此一舉，畢竟不是所有情緒表現都適合用歌舞呈現。不過在只有小丑的幾場戲中，瓦昆還是有只用演出，就把小丑的內心狀態直接帶給觀眾，當下覺得瓦昆的演技真的很厲害。</p>

<p>從劇情來看，這版的小丑不會是以往大家對小丑的印象，雖然看起來是還想要有續集，但是亞瑟的故事應該是到這裡為止了。如果想看小丑發揮的話，這部電影不是個好選擇。</p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="電影" /><category term="心得" /><summary type="html"><![CDATA[去年因為工作變得比較繁重，所以電影看的不多，不過這樣反而可以寫得比較詳細。為了篇幅，就簡單分成真人電影與動畫電影兩篇，這篇就記錄真人電影的部份。去年最喜歡的電影就是《沙丘：第二部》了，去二刷的時候還選了 IMAX 的版本，對於太空科幻的題材真的愛不釋手啊。]]></summary></entry><entry><title type="html">[分享] 2025 亞太遊戲高峰會 -《聖騎士之戰 -奮戰-》的全球化挑戰</title><link href="https://lankudot.airfishlab.com/blog/2025-01-2025-apgs-ggst-share/" rel="alternate" type="text/html" title="[分享] 2025 亞太遊戲高峰會 -《聖騎士之戰 -奮戰-》的全球化挑戰" /><published>2025-01-30T00:00:00+08:00</published><updated>2025-01-30T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/2025-apgs-ggst-share</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2025-01-2025-apgs-ggst-share/"><![CDATA[<p>在台北電玩展舉行期間，也會同時進行亞太遊戲高峰會。高峰會邀請遊戲業相關商業人士前來分享經驗，議題涵蓋開發、技術、行銷、社群推廣等。不過對我來說，與其說是去聽演講，不如說是粉絲見面會。而今年最有興趣的演講之一是 GGST 的製作人宮內健的分享，在這場演講中也獲益良多，所以用這篇文章來分享演講的內容。</p>

<p><img src="/assets/images/blog/2025/2025-01-30-2025-apgs-ggst-share/ggst-cover-image.jpg" alt="ggst-cover-image" /></p>

<p>製作人宮內健在這場演講中主要分享在開發《聖騎士之戰 -奮戰-》（GGST）中，為了能吸引新玩家，又要兼顧舊玩家，所做的改變以及面臨的問題。</p>

<h2 id="格鬥遊戲的困境">格鬥遊戲的困境</h2>

<p>以往格鬥遊戲給人難度很高的印象，緒如只要逮到就會被連段到底，無法反擊、招式又多又複雜、需要即時反應以應對場上情況。造成格鬥遊戲很難吸引新玩家，也有玩家年齡越來越高的趨勢。在 GGST 一次封測的問券調查中，有前作遊玩經驗的人高達約 95%，而且這當中有約 74% 是 25 歲以上的玩家，而剩下的 5% 沒玩過的人中，有約 60% 是 25 歲以下的玩家。為了能讓續作繼續下去，吸引新玩家變得很重要。</p>

<h2 id="內外在進行改變">內外在進行改變</h2>

<p>為了能夠吸引新玩家，在 GGST 的外在與內在都做了改變。外在的部份是讓遊戲畫面變得乾淨，該玩家容易搞清楚場上發生的狀況。內在則是不用連段或是必殺技就可以打出高傷或是華麗的招式，而在角色的攻略影片中也避免給連段的攻略，讓玩家覺得這種程度的控制我也可以。</p>

<p><img src="/assets/images/blog/2025/2025-01-30-2025-apgs-ggst-share/ggxrd-gameplay.png" alt="ggxrd-gameplay" />
<img src="/assets/images/blog/2025/2025-01-30-2025-apgs-ggst-share/ggst-gameplay.png" alt="ggst-gameplay" />
<em>與前作相比，GGST 的介面變得簡潔。上圖擷圖<a href="https://youtu.be/Mis6bx43XII">來源</a>，下圖擷圖<a href="https://youtu.be/Yr-PY1K0j_8">來源</a></em></p>

<!-- Courtesy of embedresponsively.com -->

<div class="responsive-video-container">
    <iframe src="https://www.youtube-nocookie.com/embed/H0ha3-S926k" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
  </div>

<p class="video-caption"><em>在官方的角色攻略影片中介紹單招及簡單的指令</em></p>

<h2 id="注重線上對戰">注重線上對戰</h2>

<p>在對戰環境上也要順應線上對戰變為主流的趨勢。日本的機廳文化較為盛行，習慣面對面的對戰，所以線下的本地對戰容易進行。但是在美國地域廣大，要進行線下對戰就得長途跋涉。在線上的部份，網路狀態好的地方也相對有優勢，但美國的網路在各地也有差別。然而玩家比較喜歡找到同樣程度的人對戰，如果對戰一面倒的話，贏家沒有成就感，輸家也會覺得遊戲太難，因而留不住玩家。因此在 GGST 中也導入 Rollback Netcode，它可以讓網路環境不好的玩家也能有順暢的遊戲體驗，在疫情期間舉辦的線上賽也獲得好評。</p>

<!-- Courtesy of embedresponsively.com -->

<div class="responsive-video-container">
    <iframe src="https://www.youtube-nocookie.com/embed/7yVrUcav6DI" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
  </div>

<p class="video-caption"><em>Rollback Netcode 在收到下個指令之前，先假設玩家沒有改變輸入的指令，直到收到下個指令。如果跟預測一樣，就不改變角色的行為，如果不一樣，則柔順地將角色轉到對應的動作。避免以往沒收到指令角色就不動作所造成的卡頓感</em></p>

<h2 id="現代化的角色形象">現代化的角色形象</h2>

<p>再來就是角色外觀的喜好也在改變，而且歐美人覺得美少女互歐是一件很奇怪的事情。因此在 GGST 中讓角色的視覺形象現代化，只保留覺得「很酷」的元素，也在角色年齡與服裝上做改變。而在劇情中加入對應的故事，讓角色的改變合理化。</p>

<p><img src="/assets/images/blog/2025/2025-01-30-2025-apgs-ggst-share/may-appearance-changing.png" alt="may-appearance-changing" />
<img src="/assets/images/blog/2025/2025-01-30-2025-apgs-ggst-share/dizzy-appearance-changing.png" alt="dizzy_appearance-changing" />
<em>可以看到 May 與 Dizzy 這兩個角色在前作 GGXrd 與續作 GGST 的形象改變，服裝也以日常服為為主，但還是保留主要元素</em></p>

<h2 id="與老玩家溝通">與老玩家溝通</h2>

<p>但這些改動可能會違背老玩家想要的內容，老玩家因自己喜歡的遊戲元素被去除了而反彈，造成遊戲評價下降。所以在遊戲開發階段就開始傳達想要改變的消息，透過官網（<a href="https://www.guiltygear.com/ggst/en/news/post-category/column/">開發者後花園</a>）、社群平台、媒體等管道來發佈創作意圖與未來方針。並利用問卷調查與 beta 測試，來與玩家共同討論意見，並且會公布調查結果與開發者意見。</p>

<h2 id="消費者鴻溝">消費者鴻溝</h2>

<p>他們在問卷調查中也發現了「消費者鴻溝」（<a href="https://www.business-to-you.com/crossing-the-chasm-technology-adoption-life-cycle/">The Chasm</a>）的現象。消費者對新產品的消費習慣可以分成五個族群，這邊用遊戲做為例子：</p>

<ul>
  <li>創新者（Innovators）：只要是新遊戲就一定會玩，而且會是遊戲的改進來源</li>
  <li>早期採用者（Early Adopters）：與創新者類似，但他們會依賴自己的直覺來挑選遊戲，通常也不太在意價格，而且很樂意作為其它消費者的參考對象</li>
  <li>早期大眾（Early Majority）：不會立刻玩新遊戲，而且會參考其它人的意見來決定要不要玩這款遊戲</li>
  <li>晚期大眾（Late Majority）：等遊戲有穩定評價以及價格符合期望時，才會決定玩這款遊戲</li>
  <li>落後者（Laggards）：完全不會玩新遊戲的人</li>
</ul>

<p><img src="/assets/images/blog/2025/2025-01-30-2025-apgs-ggst-share/the-chasm.png" alt="the-chasm" /></p>

<p>這些族群的人數分佈呈現常態分佈，但是可以看到早期採用者與早期大眾之間有一個間隔，被稱為「消費者鴻溝」。這是因為早期採用者的意見會成為早期大眾的參考，如果早期採用者給出負評的話，早期大眾就不會購買這款遊戲，進而流失這部份的客群。</p>

<h2 id="總結">總結</h2>

<p>因此能在開發階段主動取得玩家的意見，對於開發方向有很大的幫助。在幾次的 beta 測試中，問卷的滿意程度也大幅提升。相比前作只有 26% 的 25 歲以下的玩家，在 GGST 中則達到 72%，讓 GGST 成為 ARC System Works 第一款擁有 300 萬玩家的格鬥遊戲，成功留下系列作玩家，也吸引了新玩家。該遊戲也在 2021 年的 TGA 中獲得最佳格鬥遊戲的獎項。</p>

<p>製作人最後提到，雖然成功模式不能直接複製，但是如果可以帶來幫助的話是再好也不過。</p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="分享" /><summary type="html"><![CDATA[在台北電玩展舉行期間，也會同時進行亞太遊戲高峰會。高峰會邀請遊戲業相關商業人士前來分享經驗，議題涵蓋開發、技術、行銷、社群推廣等。不過對我來說，與其說是去聽演講，不如說是粉絲見面會。而今年最有興趣的演講之一是 GGST 的製作人宮內健的分享，在這場演講中也獲益良多，所以用這篇文章來分享演講的內容。]]></summary></entry><entry><title type="html">[雜談] 理想與現實：大公司的價值觀洗禮</title><link href="https://lankudot.airfishlab.com/blog/2024-12-work-experience-in-big-company/" rel="alternate" type="text/html" title="[雜談] 理想與現實：大公司的價值觀洗禮" /><published>2024-12-02T00:00:00+08:00</published><updated>2024-12-02T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/work-experience-in-big-company</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2024-12-work-experience-in-big-company/"><![CDATA[<p>之前工作參與的專案規模不大，或是能切分出互不影響的功能，讓每個人各自負責，所以程式功能只要顧好自己的部份就好。在進入大公司後，專案規模變大，開發勢必得要多人一起進行。然而一人開發與多人開發的情景完全不同，大公司專案專注的面向也不一樣，理所當然，就面臨了不少價值觀的衝擊。</p>

<p><img src="/assets/images/blog/2024/2024-12-02-work-experience-in-big-company/ideal-vs-reality.png" alt="ideal-vs-reality" /></p>

<h2 id="程式風格混亂">程式風格混亂</h2>

<p>起初專案並沒有明確規範程式風格，也沒有進行 code review，造成專案中充斥著不同的程式風格。然而專案為了方便維護程式碼，即使那個是不好的風格，還是被要求跟著該功能既有的程式風格撰寫程式。</p>

<p>剛加入專案那時，一直苦惱縮排到底是用 tab 還是 space，一行 200 字元的程式碼要不要幫忙換行，或是巢狀階層多到可以打波動拳了，要不要拆出函式等。起先在加新功能的時候，我會順手改掉原本程式碼中不好的風格。但後來被阻止了，原因是如果該功能出錯，會找最後一個改動的人負責任。直到這個問題變成技術債之後，專案才開始重視程式風格，慢慢明確規範程式寫法。想想如果當初在修改前，先跟主管提出程式風格的問題的話，應該可以提前重視這個問題。</p>

<p><img src="/assets/images/blog/2024/2024-12-02-work-experience-in-big-company/choose-between-tab-and-space.png" alt="choose-between-tab-and-space" />
<em>程式碼風格不一致讓人無所適從</em></p>

<p>在多人開發專案中，能有統一的程式風格相當重要，即使那個功能不是自己開發的，也能快速理解功用。另外現今編輯器可以設定程式風格的檢查，包含強制換行、變數命名格式、縮排、行尾空白等。更嚴格一點還可以搭配 git hook，只要不合規範，就不能推上去。</p>

<h2 id="功能先有最重要">功能先有最重要</h2>

<p>因為專案的性質，需要定期推出新功能，因此功能能否即時上線是最重要的，程式碼寫得好不好並不重視。加上能開發的時間不足，為了追趕時程，也為了不影響既有的功能，只能省略架構設計，直接參考既有的程式碼撰寫，或甚至直接複製一份出來改，最慘的是連驗證的時間都不足。雖然功能即時上線了，但品質卻脆弱不堪。</p>

<p>用這個方式開發的後果就是增加後續維護的難度。同一個功能被複製了好幾份，修了其中一份的 bug 後，才發現其他地方還有相同的 bug。或是要更新某個功能時，得要找出所有複製出來的功能一併修改。為了追趕一個又一個的上線時程，這樣的技術債只會越堆越高。現在省下來的時間，後來就加倍還回去了。</p>

<p><img src="/assets/images/blog/2024/2024-12-02-work-experience-in-big-company/lot-of-bug-because-of-no-time.png" alt="lot-of-bug-because-of-no-time" />
<em>趕時間開發的功能最後帶來解不完的 bug</em></p>

<p>理想的開發模式是先規劃好功能需要哪些元件，元件之間要如何互動，再去撰寫程式碼。如果是在既有功能上製作，則要再加上理解原本架構的部份。然而要能執行這樣的開發模式，除了得有足夠的開發時間，更重要的是要有健康的專案架構。但現實是專案過了好幾手之後，功能相互交雜，牽一髮而動全身。為了避免擴大麻煩，繞過原本的功能去做新功能反而是最保險的作法。</p>

<h2 id="重構永遠是最後選項">重構永遠是最後選項</h2>

<p>開發新功能時，原有的架構不敷需求的話，就一定需要重構，然而對上線的功能來說「能動的就不要動」，要重構就得要冒著既有功能壞掉的風險。當開發與驗證時間不足的時候，想要重構也無能為力，就會出現前面所說的，只能繞路或是擱置問題。</p>

<p>只是當技術債累積到不得不面對的程度，就還是得進行重構。在參與專案的期間負責過兩次大型重構，當時各花兩個月在上面：一次是因為某個底層功能太複雜，以致於影響執行效能；另一次是幾個重要機制被複製了數次，為了讓即將開發的新功能也能使用那些機制，與後續方便維護，把它們整理出來，作為共用功能。</p>

<p><img src="/assets/images/blog/2024/2024-12-02-work-experience-in-big-company/code-debt.png" alt="code-debt" />
<em>技術債終究是要還的</em></p>

<p>無論重構規模的大小，只要有重構就得驗證所有相關的功能是否正常。重構前先確認影響的範圍，如果影響範圍太大，就得思考拆分重構的規模，一次只重構一部分。好處是容易掌握需要驗證的功能，出 bug 時容易找到出問題的地方。另外重構時，通常專案也在開發，能儘早把重構後的功能合併回專案的話，也能避免該功能仍然以舊方法開發，造成還要再度重構。</p>

<h2 id="還是有收穫">還是有收穫</h2>

<p>不過參與大公司的專案可以體驗到單人專案無法體驗的事情，其中之一是可以跟其它程式交流。當不知道功能如何設計比較好時，就可以詢問其它程式的意見，往往會得到不錯的想法。另外 code review 也是很適合交換意見的時候，除了可以分享自己的做法與建議之外，也可以看到其它人的思維，做為未來寫程式時的參考。</p>

<p>另外一個就是可以訓練溝通能力。在多人專案中，當遇到不是自己做的功能，就得要詢問當初做或比較熟那個功能的人。雖然可以靠自己閱讀程式碼來理解，但如果先問相關的程式碼與執行流程，反而更能快速上手，也更能專注在要實作的功能上。反之亦然，其它人也會來問自己做的功能，能夠清楚地解釋自己的程式碼，也是很實用的能力。</p>

<p><img src="/assets/images/blog/2024/2024-12-02-work-experience-in-big-company/conversation.png" alt="conversation" />
<em>能學習跟其它人溝通是最大的收獲</em></p>

<p>除了跟程式討論之外，也會時常跟不同部門的人討論。對方詢問問題時，得先釐清真正想問的內容，最好是能將自己理解的問題內容講給對方聽，確認理解的是不是一樣的。另一方面，也盡量以對方能理解的方式講解。否則很常雞同鴨講，最後搞得雙方都很混亂。</p>

<h2 id="生於憂患">生於憂患</h2>

<p>總覺得在體驗過什麼是不好的之後，才知道什麼是好的。在這段時間中，確實是挺煎熬的過程，但也是在這樣環境中才開始思考為什麼這樣的情況是不好的，以及如何改善這樣的情況。如果能帶到下一個可以發揮的環境的話，會是很好的養份。</p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="雜談" /><summary type="html"><![CDATA[之前工作參與的專案規模不大，或是能切分出互不影響的功能，讓每個人各自負責，所以程式功能只要顧好自己的部份就好。在進入大公司後，專案規模變大，開發勢必得要多人一起進行。然而一人開發與多人開發的情景完全不同，大公司專案專注的面向也不一樣，理所當然，就面臨了不少價值觀的衝擊。]]></summary></entry><entry><title type="html">[遊記] 來去逛逛 2024 BitSummit</title><link href="https://lankudot.airfishlab.com/blog/2024-08-visit-bitsummit/" rel="alternate" type="text/html" title="[遊記] 來去逛逛 2024 BitSummit" /><published>2024-08-03T00:00:00+08:00</published><updated>2024-08-03T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/visit-bitsummit</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2024-08-visit-bitsummit/"><![CDATA[<p>去年 9 月逛了東京電玩展之後，就決定今年要來日本最大的獨立遊戲展ーBitSummit。BitSummit 每年夏天固定在京都市勸業館舉辦，為期三天，吸引世界各地的開發者與發行商來參加。而今年舉辦在 7/19 ~ 7/21（第一天為商務日），副標題為「Drift」。</p>

<p><img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/cover-image.jpg" alt="cover-image" /></p>

<p>勸業館地點就位在平安神宮附近，搭公車就可以抵達。一般入場票為 2000 日圓，門票在一般公開日的這兩天都可以入場，要事先在網路上購票，再到日本的 7-11 請店員把票券印出來，而現場也有販售當日門票。參觀時間從早上 10 點到下午 5 點，以體驗來說算是相當超值。這次會場在場館的一樓與三樓，一樓攤位有合作夥伴、學校、桌遊、Game Jam 發表等，而三樓攤位則有主舞台、開發者、發行商等。這次跟同行友人主要目標就是三樓的攤位。</p>

<p><img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/torii-gate.jpg" alt="torii-gate" />
<em>搭公車的話，就會看到平安神宮的巨大鳥居</em></p>

<p>來現場的好處一個是可以先玩到還沒發售的遊戲，另一個就是可以跟開發者交流了。交流語言的話，體感英文 7 成，日文 3 成，當然也有會中文的開發者。話題的部份，可以聊聊遊戲開發了多久、用什麼遊戲引擎開發、當初是怎麼開始的等，或是自己喜歡遊戲的哪個部份或機制，開發者都很樂意分享自己的經驗，或是接受玩家的意見。我在這過程中，才後悔自己的英文能力怎麼那麼差，不能順利表達自己有多喜歡他們的遊戲，這次回來要多多加強口說能力了:laughing:。</p>

<p><img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/motionrec-1.jpg" alt="motionrec-1" />
<img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/motionrec-2.jpg" alt="motionrec-2" />
<em>這次在會場先玩到一直有在關注的《MOTIONREC》</em></p>

<p>這兩天下來，也試玩了十幾款遊戲，因為個人喜好大多是解謎類的遊戲。像是以錄製角色移動路徑，再播放路徑讓角色移動到原本無法到達的地方的<a href="https://store.steampowered.com/app/2602230/MOTIONREC/" target="_blank">《MOTIONREC》</a>。自己是顆易碎的蛋，要怎麼安全地跳到高處，或是下降到低處的<a href="https://store.steampowered.com/app/2617090/Fowl_Damage/" target="_blank">《Fowl Damage》</a>。還有非常喜歡日本工學院專門學校蒲田校的遊戲設計科的兩款遊戲：一個是結合倉庫番與光與影，透過移動箱子與光源，利用箱子的陰影在上方形成平台，讓影之貓可以抵達目標門的<a href="https://www.youtube.com/watch?v=fafYsxdEn04" target="_blank">《迷暗》</a>。另一個是透過複製一部份區域，來取代另一部份區域，以開啟不能通過的地方的<a href="https://www.youtube.com/watch?v=nKVWYKYurAc" target="_blank">《うつルーム》</a>。同行友人與開發者聊過之後，才知道他們是直接以 C++ 寫成遊戲，物理碰撞也都是自己寫的，真心佩服。</p>

<p><img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/miann.jpg" alt="miann" />
<img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/utsu-room.jpg" alt="utsu-room" />
<em>由學生製作的《迷暗》與《うつルーム》除了機制很吸引人之外，關卡設計也很用心</em></p>

<p>會場空間不會太擁擠，在開發者區就算兩側有人排隊，中間還是有足夠空間讓一個人通過，整天逛下來很舒服。而且很多攤位有準備二台以上的試玩設備，所以如果當下想玩的遊戲需要等待的話，先去逛其它攤位再回來都還有機會玩到。另外在一樓入場後，會拿到一個主辦發的提袋，最大可以裝下 A4 L 夾，拿來裝各家文宣相當方便，不用擔心折到，也可以不用在試玩時，煩惱要如何暫放文宣品。比較可惜的是，現場並沒有宣傳袋子中有可以拿來投最喜歡遊戲的貼紙，位在三樓的投票板上的貼紙數很少，而且如果直接到三樓會場的話，也不會拿到袋子。開發《迷暗》的學生說如果有拿到人氣獎的話，就有機會出版了，感到有點可惜。</p>

<p><img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/nice-bag.jpg" alt="nice-bag" /></p>

<p>最後飲食的部份，在一樓會場內有食物攤，會場外也有餐車，附近只有一間小小的全家。午餐時間人很多，在外面排食物也很熱。如果本來就打算一整天就在會場，建議事先就買好午餐跟飲料。</p>

<p><img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/heian-shrine.jpg" alt="heian-shrine" />
<em>BitSummit 逛完不妨到平安神宮參拜</em></p>

<p>喜歡獨立遊戲的話，BitSummit 非常值得來逛一次，可以感受到來自世界各地的開發者的熱情，很有「祭典」的氛圍。會後也公布了 2025 年的 BitSummit 在 7/18 ~ 7/20 舉辦，副標題為「XIII」，也呼應下一次是第十三屆。而這時間也恰逢日本三大祭之一「祇園祭」的期間，有機會的話，不妨安排一趟京都之旅。</p>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">HOT NEWS (literally)<br /><br />BitSummit XIII⛩️<br />July 18, 19, 20, 2025<br /><br />SAVE THE DATES! <br /><br />SEE YOU NEXT YEAR EVERYONE &lt;3 <a href="https://t.co/1JnvSuTwxI">pic.twitter.com/1JnvSuTwxI</a></p>&mdash; BitSummit (@BitSummit) <a href="https://twitter.com/BitSummit/status/1814944601741939104?ref_src=twsrc%5Etfw">July 21, 2024</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="遊記" /><category term="遊戲展" /><summary type="html"><![CDATA[去年 9 月逛了東京電玩展之後，就決定今年要來日本最大的獨立遊戲展ーBitSummit。BitSummit 每年夏天固定在京都市勸業館舉辦，為期三天，吸引世界各地的開發者與發行商來參加。而今年舉辦在 7/19 ~ 7/21（第一天為商務日），副標題為「Drift」。]]></summary></entry><entry><title type="html">[閱讀] 布莉琪．柯林斯《裝幀師》</title><link href="https://lankudot.airfishlab.com/blog/2024-07-the-binding/" rel="alternate" type="text/html" title="[閱讀] 布莉琪．柯林斯《裝幀師》" /><published>2024-07-07T00:00:00+08:00</published><updated>2024-07-07T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/the-binding</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2024-07-the-binding/"><![CDATA[<p>當回憶可以被「裝幀」到書中，自此忘卻這段痛苦的經歷，從而開始新的人生，對一個人來說或許是救贖。但如果被有心人用來裝幀受害者的回憶，抑或是這些不想記起的回憶成為收藏家的玩物時，這童話故事般的能力對被裝幀的人來說是慈悲與救贖，還是自私與痛苦。</p>

<p><img src="/assets/images/blog/2024/2024-07-07-the-binding/cover-image.jpg" alt="cover-image" /></p>

<p>主角艾墨特天生擁有裝幀師的能力，但是生長的地方卻把書視為詛咒之物，碰到書只有挨打的份。然而艾墨特生了一場重病，才發現患有「裝幀師熱」，家人在萬般不願意之下，只能將他送到裝幀所當學老裝幀師ー瑟芮狄絲ー的學徒。雖然艾墨特在成為學徒後，症狀逐漸改善，瑟芮狄絲卻遲遲不教導他關於「裝幀」的技術。隨著日子推移，艾墨特發病時會夢到的景象也越來越清晰，然而卻發現這個夢似乎是解答自己遭遇的關鍵，這背後隱藏著更大的事件。</p>

<p>一個故事讓人想要繼續閱讀，就是因為有許多問號等著解答。在知道解答時，會有種「原來是這樣啊」的感覺，但《裝幀師》在解答問題的時候，則是讓人有「什麼！居然是這樣」的感覺。意識到原來前面只知道真相的一半，對劇情的認知是錯的，每個人物看似平常的行為，其實背後都是有原因的。當初進入解答的篇章時，還一直來回對照前面的劇情，看得速度也越來越快，就是希望快點知道整個事件的全貌。</p>

<p>《裝幀師》故事分成三個篇章，鋪陳與事件篇、解答篇、解決篇，個人覺得解答篇是全書的高潮，但進入解答篇之前放的劇情高點更是畫龍點睛，從這裡才意識到「有什麼認真的要來了」。而解決篇也很有趣，是從另一個人的觀點繼續把故事延續下去，同時也在收束前面的伏筆。在看之前，原本以為《裝幀師》是奇幻故事，看了才發現是一個充滿人心黑暗的故事。</p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="閱讀" /><category term="心得" /><summary type="html"><![CDATA[當回憶可以被「裝幀」到書中，自此忘卻這段痛苦的經歷，從而開始新的人生，對一個人來說或許是救贖。但如果被有心人用來裝幀受害者的回憶，抑或是這些不想記起的回憶成為收藏家的玩物時，這童話故事般的能力對被裝幀的人來說是慈悲與救贖，還是自私與痛苦。]]></summary></entry><entry><title type="html">[Unity] 事件訂閱與問題（下）- C# 介面</title><link href="https://lankudot.airfishlab.com/blog/2024-04-unity-event-subscription-and-problem-2/" rel="alternate" type="text/html" title="[Unity] 事件訂閱與問題（下）- C# 介面" /><published>2024-04-13T00:00:00+08:00</published><updated>2024-04-13T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/unity-event-subscription-and-problem-2</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2024-04-unity-event-subscription-and-problem-2/"><![CDATA[<p>本篇繼續<a href="/blog/2024-04-unity-event-subscription-and-problem-1/">上一篇</a>的內容來介紹第三種事件訂閱的方式：C# 介面。並在最後比較這三種訂閱方式。</p>

<h2 id="c-介面">C# 介面</h2>

<p>使用 C# 介面讓物件提供事件的處理函式，並把物件註冊到事件系統上以訂閱事件。在 Unity 的 <code class="language-plaintext highlighter-rouge">EventSystems</code> 中就是使用 C# 介面讓物件訂閱操作事件。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">UIPuzzleImage</span> <span class="p">:</span> <span class="n">MonoBehaviour</span><span class="p">,</span>
    <span class="n">IBeginDragHandler</span><span class="p">,</span> <span class="n">IDragHandler</span><span class="p">,</span> <span class="n">IEndDragHandler</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">OnBeginDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnBeginDrag"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">OnDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnDrag"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">OnEndDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnEndDrag"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="實作事件系統">實作事件系統</h3>

<p>使用 C# 介面做為事件訂閱的方式，還需要自行管理訂閱的物件，以觸發事件。這邊使用 <code class="language-plaintext highlighter-rouge">HashSet</code> 來儲存訂閱的物件，好處是就算物件重複訂閱，在 <code class="language-plaintext highlighter-rouge">HashSet</code> 中也不會出現兩個物件。而且如果有需要，還可以先檢查該物件有沒有先訂閱了，而輸出警告訊息甚至是 exception。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">ILevelEventHandler</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">OnLevelStart</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">LevelManager</span> <span class="n">Instance</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">readonly</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">ILevelEventHandler</span><span class="p">&gt;</span> <span class="n">_levelEventHandlers</span> <span class="p">=</span> <span class="k">new</span> <span class="p">();</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Instance</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">SubscribeLevelEvent</span><span class="p">(</span><span class="n">ILevelEventHandler</span> <span class="n">handler</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 也可不檢查</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_levelEventHandlers</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="n">handler</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">handler</span><span class="p">}</span><span class="s"> 已經被註冊過了"</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">_levelEventHandlers</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">UnsubscribeLevelEvent</span><span class="p">(</span><span class="n">ILevelEventHandler</span> <span class="n">handler</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_levelEventHandlers</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">LevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">handler</span> <span class="k">in</span> <span class="n">_levelEventHandlers</span><span class="p">)</span>
            <span class="n">handler</span><span class="p">.</span><span class="nf">OnLevelStart</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>而用 C# 介面訂閱事件的優點是不能用匿名函式訂閱事件，一定要是物件中明確實作的函式。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span> <span class="p">:</span> <span class="n">MonoBehaviour</span><span class="p">,</span> <span class="n">ILevelEventHandler</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">SubscribeLevelEvent</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnDestory</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">UnsubscribeLevelEvent</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 明確介面實作，讓事件函式只能透過 ILevelEventHandler 介面呼叫</span>
    <span class="k">void</span> <span class="n">ILevelEventHandler</span><span class="p">.</span><span class="nf">OnLevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="c-介面的問題">C# 介面的問題</h3>

<h4 id="讓訂閱物件提供過多的-public-函式">讓訂閱物件提供過多的 <code class="language-plaintext highlighter-rouge">public</code> 函式</h4>

<p>會發現使用介面可能會讓物件提供過多的 <code class="language-plaintext highlighter-rouge">public</code> 函式，但是可以透過明確介面實作，讓實作的介面函式，只能透過介面型別呼叫。要注意在明確介面實作中，實作的函式是沒有 <code class="language-plaintext highlighter-rouge">public</code> 的。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">UIPuzzleImage</span> <span class="p">:</span> <span class="n">MonoBehaviour</span><span class="p">,</span>
    <span class="n">IBeginDragHandler</span><span class="p">,</span> <span class="n">IDragHandler</span><span class="p">,</span> <span class="n">IEndDragHandler</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="n">IBeginDragHandler</span><span class="p">.</span><span class="nf">OnBeginDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnBeginDrag"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="n">IDragHandler</span><span class="p">.</span><span class="nf">OnDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnDrag"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="n">IEndDragHandler</span><span class="p">.</span><span class="nf">OnEndDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnEndDrag"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">SomeClass</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
    <span class="k">private</span> <span class="n">UIPuzzleImage</span> <span class="n">_puzzleImage</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">SomeFunc</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Error</span>
        <span class="c1">//_puzzleImage.OnDrag(null);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="事件觸發測試">事件觸發測試</h2>

<p>以下在 Unity 中，以生成 1000 個物件測試觸發事件時的秏時。測試方式為一次觸發事件 10 次，取平均運行時間。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">StopWatch</span> <span class="n">_stopWatch</span> <span class="p">=</span> <span class="k">new</span> <span class="p">();</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">InvokeEvent</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">ticks</span> <span class="p">=</span> <span class="m">0L</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_stopWatch</span><span class="p">.</span><span class="nf">Restart</span><span class="p">();</span>
        <span class="c1">// 如果是 C# 介面則用 foreach 去逐個觸發事件</span>
        <span class="n">_onEvent</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">();</span>
        <span class="n">_stopWatch</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>
        <span class="n">ticks</span> <span class="p">+=</span> <span class="n">_stopWatch</span><span class="p">.</span><span class="n">ElapsedTicks</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">ticks</span> <span class="p">/</span> <span class="m">10f</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>而首次執行中，因為 JIT 編譯器要轉換 IL 成可執行的機器碼，所以會比較花時間，因此分別列出：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">[在編輯器]<br />首次執行</th>
      <th style="text-align: center">[在編輯器]<br />首次之後</th>
      <th style="text-align: center">[執行檔]<br />首次執行</th>
      <th style="text-align: center">[執行檔]<br />首次之後</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">UnityEvent</code></td>
      <td style="text-align: center">257.7 ticks</td>
      <td style="text-align: center">175.5 ticks</td>
      <td style="text-align: center">248.4 ticks</td>
      <td style="text-align: center">153.4 ticks</td>
    </tr>
    <tr>
      <td style="text-align: center">C# <code class="language-plaintext highlighter-rouge">event</code></td>
      <td style="text-align: center">127.3 ticks</td>
      <td style="text-align: center">31.2 ticks</td>
      <td style="text-align: center">194.2 ticks</td>
      <td style="text-align: center">28.7 ticks</td>
    </tr>
    <tr>
      <td style="text-align: center">C# 介面</td>
      <td style="text-align: center">150.9 ticks</td>
      <td style="text-align: center">35.1 ticks</td>
      <td style="text-align: center">260 ticks</td>
      <td style="text-align: center">32.9 ticks</td>
    </tr>
  </tbody>
</table>

<p>可以發現除了在執行檔中，第一次執行時，C# 介面會比較慢之外，執行的速度由快到慢為：C# <code class="language-plaintext highlighter-rouge">event</code>、C# 介面、<code class="language-plaintext highlighter-rouge">UnityEvent</code>。</p>

<h2 id="總結">總結</h2>

<p>整理這三種訂閱事件方式的問題比較表：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">過多<br /><code class="language-plaintext highlighter-rouge">public</code> 函式</th>
      <th style="text-align: center">被外部<br />觸發事件</th>
      <th style="text-align: center">重複訂閱</th>
      <th style="text-align: center">註冊<br />匿名函式</th>
      <th style="text-align: center">處理速度</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">UnityEvent</code></td>
      <td style="text-align: center">會</td>
      <td style="text-align: center">僅 <code class="language-plaintext highlighter-rouge">public</code></td>
      <td style="text-align: center">可</td>
      <td style="text-align: center">可</td>
      <td style="text-align: center">慢</td>
    </tr>
    <tr>
      <td style="text-align: center">C# <code class="language-plaintext highlighter-rouge">event</code></td>
      <td style="text-align: center">不會</td>
      <td style="text-align: center">不可</td>
      <td style="text-align: center">可</td>
      <td style="text-align: center">可</td>
      <td style="text-align: center">快</td>
    </tr>
    <tr>
      <td style="text-align: center">C# 介面</td>
      <td style="text-align: center">會，可避免</td>
      <td style="text-align: center">僅 <code class="language-plaintext highlighter-rouge">public</code></td>
      <td style="text-align: center">不可</td>
      <td style="text-align: center">不可</td>
      <td style="text-align: center">次快</td>
    </tr>
  </tbody>
</table>

<p>Unity 事件訂閱方式有各自的好處，但相對的也有各自的問題。如果沒注意事件訂閱的管理的話，只要遊戲規模一大，就很容易出問題，而且還很難找出原因。而在這三種方法中，我會推薦使用 C# 介面做為事件訂閱的方法，因為相比其它兩種方式比較不容易出錯。而且追蹤有訂閱的物件也方便，只要找出有實作該介面的類別就可以了。</p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="筆記" /><category term="Unity" /><category term="C#" /><summary type="html"><![CDATA[本篇繼續上一篇的內容來介紹第三種事件訂閱的方式：C# 介面。並在最後比較這三種訂閱方式。]]></summary></entry><entry><title type="html">[Unity] 事件訂閱與問題（上）- `UnityEvent` 與 C# `event`</title><link href="https://lankudot.airfishlab.com/blog/2024-04-unity-event-subscription-and-problem-1/" rel="alternate" type="text/html" title="[Unity] 事件訂閱與問題（上）- `UnityEvent` 與 C# `event`" /><published>2024-04-08T00:00:00+08:00</published><updated>2024-04-08T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/unity-event-subscription-and-problem-1</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2024-04-unity-event-subscription-and-problem-1/"><![CDATA[<p>在遊戲開發中，一個物件經常需要訂閱另一個物件的事件，以在事件發生時，執行對應的動作，像是玩家輸入、觸發機關、關卡管理等。而在 Unity 中，常見的方式是使用 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 與 C# <code class="language-plaintext highlighter-rouge">event</code> 來讓物件提供事件介面，讓其它物件訂閱，但這兩者各自問題，反而讓程式容易出錯。本篇文章整理 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 與 C# <code class="language-plaintext highlighter-rouge">event</code>，並講解可能的問題，而下篇則會介紹利用 C# 介面做為事件介面的第三種方式。</p>

<h2 id="unityevent"><code class="language-plaintext highlighter-rouge">UnityEvent</code></h2>

<p><code class="language-plaintext highlighter-rouge">UnityEvent</code> 在 Unity 中是最常見的訂閱事件方法，好處是讓其它物件可以在 inspector 上直接設定事件的處理函式（event handler）。通常在設計套件時，會經常使用 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 來讓使用者可以從介面設定處理函式，但這也是 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 的唯一好處了。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
    <span class="k">private</span> <span class="n">UnityEvent</span> <span class="n">_onLevelStart</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="unityevent-的問題"><code class="language-plaintext highlighter-rouge">UnityEvent</code> 的問題</h3>

<h4 id="讓訂閱的物件提供過多的-public-函式">讓訂閱的物件提供過多的 <code class="language-plaintext highlighter-rouge">public</code> 函式</h4>

<p>使用 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 的一個大問題就是想要訂閱事件的物件得要提供 <code class="language-plaintext highlighter-rouge">public</code> 函式才能在 inspector 中設置處理函式，這會讓其它物件也有機會去呼叫這個處理函式。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">OnLevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>例如：敵人物件為了在 inspector 上能訂閱關卡開始的事件，就得要提供一個 <code class="language-plaintext highlighter-rouge">public</code> 的函式，這讓其它有參考這個敵人的物件也有機會呼叫 <code class="language-plaintext highlighter-rouge">OnLevelStart</code>。</p>

<p>而且如果該物件需要接入不同的事件時，這些 <code class="language-plaintext highlighter-rouge">public</code> 函式就會越來越多。在寫程式時，就會多出許多不必要的候選函式，造成困擾。</p>

<h4 id="外部物件能觸發事件">外部物件能觸發事件</h4>

<p>除了透過 inspector 設置處理函式之外，通常也會讓處理函式能在程式中設置。雖然可以讓要訂閱事件的物件在自己內部訂閱，而能將處理函式設為 <code class="language-plaintext highlighter-rouge">private</code> 的，但為此將 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 設為 <code class="language-plaintext highlighter-rouge">public</code> 的話，反而會讓其它物件有機會呼叫 <code class="language-plaintext highlighter-rouge">Invoke()</code> 來觸發事件。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">LevelManager</span> <span class="n">Instance</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">UnityEvent</span> <span class="n">OnLevelStart</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Instance</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span><span class="p">.</span><span class="nf">AddListener</span><span class="p">(</span><span class="n">OnLevelStart</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnLevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">SomeObject</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">SomeFunc</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 不相關的物件可以呼叫</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>例如：為了能在程式中訂閱事件，<code class="language-plaintext highlighter-rouge">LevelManager</code> 將 <code class="language-plaintext highlighter-rouge">OnLevelStart</code> 事件設為 <code class="language-plaintext highlighter-rouge">public</code>，雖然可以讓 <code class="language-plaintext highlighter-rouge">Eneny</code> 物件在程式中訂閱事件，但可能讓其它物件不小心觸發到關卡開始的事件，造成意外的結果。</p>

<p>要避免這種情況的話，就還是把 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 物件宣告為 <code class="language-plaintext highlighter-rouge">private</code> 的，並讓物件提供訂閱事件的函式。如果還是要保留在 inspector 設置處理函式的功能，則加上 <code class="language-plaintext highlighter-rouge">SerializeField</code> 屬性。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
    <span class="k">private</span> <span class="n">UnityEvent</span> <span class="n">_onLevelStart</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">SubscribeOnLevelStart</span><span class="p">(</span><span class="n">UnityAction</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_onLevelStart</span><span class="p">.</span><span class="nf">AddListener</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">UnsubscribeOnLevelStart</span><span class="p">(</span><span class="n">UnityAction</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_onLevelStart</span><span class="p">.</span><span class="nf">RemoveListener</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="重複訂閱事件">重複訂閱事件</h4>

<p>無論是透過 inspector 還是 <code class="language-plaintext highlighter-rouge">AddListener()</code> 來訂閱事件，都有可能會重複訂閱，造成同一個事件處理函式被呼叫數次。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PlayerInputManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">PlayerInputManager</span> <span class="n">Instance</span><span class="p">;</span>

    <span class="p">[</span><span class="n">NonSerialized</span><span class="p">]</span>
    <span class="k">public</span> <span class="n">UnityEvent</span> <span class="n">OnFire</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">UnityEvent</span><span class="p">();</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Instance</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="nf">GetKeyDown</span><span class="p">(</span><span class="n">KeyCode</span><span class="p">.</span><span class="n">F</span><span class="p">))</span>
            <span class="n">OnFire</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Player</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">PlayerInputManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnFire</span><span class="p">.</span><span class="nf">AddListener</span><span class="p">(</span><span class="n">OnPlayerFire</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Init</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 重複訂閱</span>
        <span class="n">PlayerInputManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnFire</span><span class="p">.</span><span class="nf">AddListener</span><span class="p">(</span><span class="n">OnPlayerFire</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnPlayerFire</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnPlayerFire"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>例如：在 <code class="language-plaintext highlighter-rouge">Player</code> 物件在訂閱玩家的輸入事件時，不小心在 <code class="language-plaintext highlighter-rouge">Start()</code> 跟給外部呼叫的 <code class="language-plaintext highlighter-rouge">Init()</code> 中各訂閱一次 <code class="language-plaintext highlighter-rouge">OnFire</code> 事件，讓玩家在按下發射按鍵時，執行兩次發射行為。而且更有可能在玩家復活時，呼叫 <code class="language-plaintext highlighter-rouge">Init()</code> 來重置 <code class="language-plaintext highlighter-rouge">Player</code> 物件的狀態，造成每次復活後，會執行更多次發射行為。</p>

<h2 id="c-event">C# <code class="language-plaintext highlighter-rouge">event</code></h2>

<p>在 Unity 中，另一個訂閱事件的方式是使用 C# 的 <code class="language-plaintext highlighter-rouge">event</code>。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">LevelManager</span> <span class="n">Instance</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">event</span> <span class="n">Action</span> <span class="n">OnLevelStart</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Instance</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>C# <code class="language-plaintext highlighter-rouge">event</code> 的優點是外部物件只能訂閱事件，而無法觸發事件，只能由宣告事件的物件呼叫 <code class="language-plaintext highlighter-rouge">Invoke()</code>：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">LevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">OnLevelStart</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span> <span class="p">+=</span> <span class="n">OnLevelStart</span><span class="p">;</span>
        <span class="c1">// 無法呼叫 Invoke</span>
        <span class="c1">// LevelManager.Instance.OnLevelStart.Invoke();</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnLevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>而且比起 <code class="language-plaintext highlighter-rouge">UnityEvent</code>，C# <code class="language-plaintext highlighter-rouge">event</code> 呼叫處理函式的時間相對少很多。</p>

<h3 id="c-event-的問題">C# <code class="language-plaintext highlighter-rouge">event</code> 的問題</h3>

<h4 id="重複訂閱事件-1">重複訂閱事件</h4>

<p>不過 C# <code class="language-plaintext highlighter-rouge">event</code> 還是會發生重複訂閱事件的問題，如果同一個處理函式被重複訂閱，一樣會被呼叫數次。另一個問題是，在取消訂閱時，重複訂閱的函式只會被移除一個。但是這個情況在 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 中反而不會發生，因為呼叫 <code class="language-plaintext highlighter-rouge">RemoveListener()</code> 取消訂閱時，重複的訂閱函式都會被移除。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span> <span class="p">+=</span> <span class="n">OnLevelStart</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Init</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span> <span class="p">+=</span> <span class="n">OnLevelStart</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnDisable</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 只會移除其中一個處理函式</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span> <span class="p">-=</span> <span class="n">OnLevelStart</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnLevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>例如：<code class="language-plaintext highlighter-rouge">Enemy</code> 物件在 <code class="language-plaintext highlighter-rouge">Start()</code> 跟 <code class="language-plaintext highlighter-rouge">Init()</code> 各訂閱一次 <code class="language-plaintext highlighter-rouge">OnLevelStart</code> 事件，在 <code class="language-plaintext highlighter-rouge">OnDisable</code> 中取消訂閱時，就只會移除一個處理函式。當 <code class="language-plaintext highlighter-rouge">OnLevelStart</code> 事件觸發時，還是會看到有訊息輸出，讓原本被關閉的 <code class="language-plaintext highlighter-rouge">Enemy</code> 物件又開始執行。</p>

<h4 id="無物件訂閱">無物件訂閱</h4>

<p>在觸發 C# <code class="language-plaintext highlighter-rouge">event</code> 時，要注意如果該 event 沒有任何物件訂閱，或是因為取消訂閱到空時，此時事件物件會被設為 <code class="language-plaintext highlighter-rouge">null</code>，如果這時觸發事件會出現 null reference exception，所以最好以 <code class="language-plaintext highlighter-rouge">onEvent?.Invoke()</code> 來觸發事件。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">event</span> <span class="n">Action</span> <span class="n">OnLevelStart</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">LevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">OnLevelStart</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="匿名函式">匿名函式</h4>

<p>如果以匿名函式訂閱事件時，該函式就再也無法被取消訂閱了，這也會發生在 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 上。因為就算內容完全一樣，在不同地方宣告的匿名函式是不同的。所以應該要避免用匿名函式訂閱事件。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Init</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span> <span class="p">+=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnDisable</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 無法取消在 Init() 訂閱的事件</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span> <span class="p">-=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>例如：敵人物件在 <code class="language-plaintext highlighter-rouge">Init()</code> 用匿名函式訂閱了 <code class="language-plaintext highlighter-rouge">OnLevelStart</code> 事件，但在 <code class="language-plaintext highlighter-rouge">OnDisable()</code> 取消訂閱時，無法移除前面用來訂閱的函式。</p>

<h2 id="小結">小結</h2>

<p>這邊小結這兩種事件訂閱方式的優點與要注意的問題：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">UnityEvent</code>
    <ul>
      <li>優點
        <ul>
          <li>可以在 inspector 中設定處理函式</li>
        </ul>
      </li>
      <li>問題
        <ul>
          <li>讓訂閱的物件提供過多的 <code class="language-plaintext highlighter-rouge">public</code> 函式</li>
          <li>外部物件能觸發事件</li>
          <li>重複註冊</li>
          <li>可以用匿名函式註冊</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>C# <code class="language-plaintext highlighter-rouge">event</code>
    <ul>
      <li>優點
        <ul>
          <li>只有宣告事件的物件才能觸發事件</li>
          <li>執行速度快</li>
        </ul>
      </li>
      <li>問題
        <ul>
          <li>重複註冊</li>
          <li>無物件訂閱時，會是 <code class="language-plaintext highlighter-rouge">null</code></li>
          <li>可以用匿名函式註冊</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="筆記" /><category term="Unity" /><category term="C#" /><summary type="html"><![CDATA[在遊戲開發中，一個物件經常需要訂閱另一個物件的事件，以在事件發生時，執行對應的動作，像是玩家輸入、觸發機關、關卡管理等。而在 Unity 中，常見的方式是使用 UnityEvent 與 C# event 來讓物件提供事件介面，讓其它物件訂閱，但這兩者各自問題，反而讓程式容易出錯。本篇文章整理 UnityEvent 與 C# event，並講解可能的問題，而下篇則會介紹利用 C# 介面做為事件介面的第三種方式。]]></summary></entry></feed>