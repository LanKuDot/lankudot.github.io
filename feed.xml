<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://lankudot.airfishlab.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lankudot.airfishlab.com/" rel="alternate" type="text/html" /><updated>2025-05-06T00:00:30+08:00</updated><id>https://lankudot.airfishlab.com/feed.xml</id><title type="html">烏龜漫遊 2.0</title><subtitle>記錄分享在 Unity 上製作遊戲的筆記與心得</subtitle><author><name>烏龜</name></author><entry><title type="html">[遊記] 2025 F1 日本大獎賽 - 行程準備</title><link href="https://lankudot.airfishlab.com/blog/2025-05-f1-japan-grand-prix-trip-planning/" rel="alternate" type="text/html" title="[遊記] 2025 F1 日本大獎賽 - 行程準備" /><published>2025-05-03T00:00:00+08:00</published><updated>2025-05-03T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/f1-japan-grand-prix-trip-planning</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2025-05-f1-japan-grand-prix-trip-planning/"><![CDATA[<p>自 2020 年入坑以來，看 F1 也進入第 6 年了。大概從前年萌生到現場看比賽的念頭，也看了一些現場觀賽的分享文後，毅然決然選定了今年的日本大獎賽。選擇日本場的原因除了日本旅遊環境友善之外，比賽舉辦的時間剛好落在清明連假，賽道當地的鈴鹿與鄰近的名古屋也是櫻花季的時期，因此這趟現地之旅就成行了。受惠於前人的分享文，所以這篇文章也來分享如何規劃行程。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/suzuka-circuit-gp-entrance.png" alt="suzuka-circuit-gp-entrance" /></p>

<h2 id="門票">門票</h2>

<p>通常在比賽舉辦日的半年前開始售票，像今年日本大獎賽辦在 4 月初，去年 10 月中開放購票。所以在去年公布今年的賽曆之後，就開始關注售票的資訊了。購買 F1 日本大獎賽門票的管道有兩個：<a href="https://tickets.formula1.com/en" target="_blank">F1 官網</a>與賽道方使用的 <a href="https://ticket.mobilitystation.jp/" target="_blank">Mobility Station</a>，雖然 F1 官網會比賽道方還要早開放售票，但是只能選區域不能選座位，而且價格也貴上許多。而賽道官網則是有限制可以購買的國家，但今年台灣可以從賽道官網購票，此外還可以選擇位置，所以我這次是透過賽道官網購票。</p>

<p>在開放售票前就可以先研究要買哪一區，在<a href="https://www.suzukacircuit.jp/zh-tw/course_s/" target="_blank">賽道官網</a>上可以看到每一區的視野與影片。位置選擇的話可以考量：</p>

<ul>
  <li>視野好不好：能看到賽車經過的時間有多久，另外下層座位可能被護欄和鐵網擋到</li>
  <li>能不能看到螢幕：鈴鹿賽道一圈約 1 分半，大約有 1 分鐘沒有賽車經過，所以能看到螢幕的話，就可以知道其它地方發生了什麼事，上面也有即時的排名與秒差。在賽道官網的視野地圖上也有標出螢幕的設置位置</li>
  <li>超車熱點：比賽最刺激的就是看超車攻防，通常會發生在 DRS 區的尾端</li>
</ul>

<p>我偏向超車熱點，以鈴鹿賽道來說就是大直線的尾端的 A2 區或是第 1, 2 彎的 B2 區，比賽大部份的超車都發生在這裡，也是起跑後的第一個攻防點。此外這兩個區可以完整看到賽車入彎到出彎，另外鈴鹿賽道的第 1 彎的入彎速度也很快，可以體驗到速度感。而 A2 區還可以看到賽車出 pit lane，當然這兩區的價格上也不便宜。如果有預算上的限制，在選擇上可以以能不能看到螢幕為優先選擇。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/a2-zone-in-map.png" alt="a2-zone-in-map" />
<em>F1 舉行時會增設看臺，A2 區就是其中之一</em></p>

<p>在門票開賣那天，理所當然會湧入大量購票者，Mobility Station 也會有流量管制。但進入排隊也不用覺得沒希望，而且也可能提前進入購買頁面（顯示 90 分鐘以上等待，但沒多久就進入頁面了），所以要時時留意排隊狀況。然而如果一開始瞄準的是熱門區域的話，最好要有備案。我這次排了 1 小時之後，B2 區售罄，但 A2 區還是有很多位置可以選，最後就選了 A2 區後排，也可以看到螢幕的位置。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/a2-zone-view-1.png" alt="a2-zone-view-1" />
<img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/a2-zone-view-2.png" alt="a2-zone-view-2" />
<em>A2 區的視野，可以看到 pit 出口以及第 1, 2 彎，這邊也是超車熱點</em></p>

<p>使用 Mobility Station 購買門票會是電子票券，當天進場就直接用票券顯示的 QR Code 即可，在比賽日進入座位區也要再出示座位資訊，如果不放心也可以印出來備用。</p>

<h2 id="行程安排">行程安排</h2>

<p>F1 日本站賽程一樣為期三天，週五的練習，週六的練習與排位賽，跟週日的重頭戲正賽。另外，鈴鹿賽道在週四早上 9 點到 12 點還有開放參觀賽道的起點大直線與 pit lane，可以走在賽道上及看到車隊在車庫整備，是不容錯過的機會，所以可以從週四開始安排行程。而鈴鹿賽道鄰近名古屋，在沒有看比賽的時間也可以在名古屋旅遊。我這次的行程安排是這樣：</p>

<table>
  <thead>
    <tr>
      <th>日期</th>
      <th>行程</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4/2 (三)</td>
      <td>中午抵達日本</td>
    </tr>
    <tr>
      <td>4/3 (四)</td>
      <td>早上參加賽道日、下午回名古屋</td>
    </tr>
    <tr>
      <td>4/4 (五)</td>
      <td>名古屋</td>
    </tr>
    <tr>
      <td>4/5 (六)</td>
      <td>鈴鹿賽道</td>
    </tr>
    <tr>
      <td>4/6 (日)</td>
      <td>鈴鹿賽道</td>
    </tr>
    <tr>
      <td>4/7 (一)</td>
      <td>中午回台灣</td>
    </tr>
  </tbody>
</table>

<p>基本上到了賽道後，就會整天待在那邊，所以除了觀看 F1 之外，還可以安排其它活動。像是同期間也會有其它賽事，這次有保時捷卡雷拉盃（Porsche Carrera Cup）跟法拉利挑戰賽（Ferrari Challenge）的賽程，可以體驗不同賽車車種的音浪。戶外廣場有車手週邊與活動攤位，主舞臺也有車手訪談與知識分享，在官方網站中都會公佈相關時間表，可以在比賽間隔前去聆聽。此外鈴鹿賽道裡還有遊樂園與本田博物館，遊樂園的摩天輪可以飽覽整個賽道，博物館則有展出許多經典的 F1 賽車。不過主舞臺、遊樂園、博物館都在離在正門比較近的區域，如果觀賽座位在比較遠的地方，可以在進場之後，先去逛這些地方，下午再到座位上觀賽。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/ferris-wheel.png" alt="ferris-wheel" />
<img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/view-from-ferris-wheel.png" alt="view-from-ferris-wheel" />
<em>摩天輪一圈約 15 分鐘，可以一覽整個園區</em></p>

<p>非常推薦在週四就到賽道，除了賽道日活動之外，因為人潮不多，遊樂園或是活動攤位很好排，是體驗這些設施的好時間。另外這天就可以購買車手與賽道的週邊，除了商品充足之外，一樣也不太需要排隊，比賽日也不需要大包小包。而且這天的座位區不用驗票，所以也可以去看看在大直道的座位體驗是什麼感覺。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/v-zone-view.png" alt="v-zone-view" />
<em>在賽道日去了 V 區坐了一下，可以看到 pit 的工作情況</em></p>

<h2 id="機票與飯店">機票與飯店</h2>

<p>因為是清明連假期間，所以即使是廉航，票價一樣不便宜。像這次是搭虎航，來回就要 2 萬 4，後續關注價格也越來越貴，但說不定其實後來有促消特價，只是考慮到連假機票比較搶手，所以在一開賣就購買機票了。不過如果可以提前幾天出發或是晚幾天回來的話，機票價格就可以少掉一半。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/window-view-from-airplane.png" alt="window-view-from-airplane" />
<em>一直很想坐窗邊的位子，這次終於圓夢了</em></p>

<p>至於飯店的部份，地點首選是名古屋。除了方便抵達賽道之外，週圍行程也很好安排，另外晚上從賽道回來也還有地方可以吃晚餐。我這次是住在榮附近的飯店，搭地鐵到名古屋站不到 10 分鐘，而且榮地鐵站也是重要節點，搭乘到其它地方也相當方便。</p>

<p>然而因為會有十幾萬人來參加 F1 賽事，所以飯店也是非常搶手，另外價格也會比平常高。這次在訂完 F1 門票之後才開始找飯店，但發現交通比較方便又價格可以接受的選擇不多了。建議可以提前找能夠退訂的飯店，選擇應該會比較多，而且到時沒有搶到 F1 門票的話，也可以再退訂就好。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/nagoya-prime-central-tower.png" alt="nagoya-prime-central-tower" />
<em>中部電力塔就在住宿飯店附近</em></p>

<h2 id="交通">交通</h2>

<p>到賽道可以選擇自駕或是搭乘大眾交通工具，而我只能選擇大眾交通。從名古屋到賽道有兩個選擇，一個是從名古屋站搭乘近鐵線到白子車站，再轉搭接駁車到賽道，是我這次的搭乘方式；另一個是從名古屋站搭 JR 線到四日市站，再轉乘伊勢鐵道到鈴鹿稻生站，最後走路到賽道。這兩個的差別主要是前者可以不用走太多路，也不用轉乘，而後者則是可以從一號彎門入場，不過也可以再走到正門入場。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/train-and-bus-access-information.png" alt="train-and-bus-access-information" /></p>

<p>搭乘近鐵可以事先在近鐵的<a href="https://www.ticket.kintetsu.co.jp/vs/en/T/TZZ/TZZ10.do?op=tDisplayVisitorMenu">官方網站</a>上預訂特急的車票，搭乘特急的好處是有位子坐之外，停的車站也比較少，特急約 40 分鐘，而急行則是要 1 小時。近鐵的特急車票是由普通車票與特急乘車券兩張車票構成，可以想成一張是基本費用，另一張則是升等特急車廂的車票。從名古屋到白子的費用是基本車資 1000 日元加上特急車資 920 日元。而能在官網預訂的只有特急乘車券，而且只提供電子證明（沒有 QR Code，也不能領實體票），所以預訂完成後要將座位資訊擷圖下來供查票用，但進站時不用特別出示。普通車票則是在進站時刷 IC 卡或是在車站購買車票，但不建議用電子車票，因為現場出站人潮多，然而 QR Code 掃描機數量不多，很容易塞住。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/shiroko-station.png" alt="shiroko-station" />
<em>白子車站前圓環的歡迎布條</em></p>

<p>到白子車站後，跟著人群走就會到接駁車的等待隊伍。我分別在週六 9 點與週日 8 點抵達車站，排隊隊伍算順暢，大約 15 ~ 20 分鐘後上接駁車，車程約 30 分鐘。接駁車車資 500 日元，是在接駁車下車處支付，可以用 IC 卡也可以付現，所以不用在上車時付錢。而下車處是在賽道外的停車場，所以還要再走 20 分鐘才會到正門。不過週四的接駁車不太一樣，因為非比賽日，所以班次比較少，雖然人也不多，但是我剛好遇到沒班的時間，等了 1 小時多才搭到，不過下車處在正門口，另外是在乘車處支付票錢。</p>

<p>這次去程的時間是這樣：</p>

<table>
  <thead>
    <tr>
      <th>時間</th>
      <th>名古屋出發</th>
      <th>白子抵達</th>
      <th>接駁車上車</th>
      <th>抵達賽道正門</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>週四</td>
      <td>(四日市出發，急行)</td>
      <td>9:20</td>
      <td>10:35</td>
      <td>11:10</td>
    </tr>
    <tr>
      <td>週六</td>
      <td>8:10</td>
      <td>8:49</td>
      <td>9:10</td>
      <td>10:00</td>
    </tr>
    <tr>
      <td>週日</td>
      <td>7:30</td>
      <td>8:09</td>
      <td>8:30</td>
      <td>9:20</td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/ticket-booth.png" alt="ticket-booth" />
<em>接駁車下車處的付錢處，左邊是付現買票，右邊則是刷 IC 卡</em></p>

<p>當然越晚出發人潮越多，等待時間就越久。為了避免花太多時間在排隊上，比較建議比賽日早上 7 點到白子車站，早一點到賽道就可以好好逛逛，而且在主舞臺週五週六兩天的車手訪談分別是在 10 點跟 9 點半開始，晚到就錯過了。而週四賽道日則建議 8 點到白子車站，因為賽道與 pit lane 參觀的開放時間只到中午 12 點，我這次 11 點到賽道差點來不及。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/saturday-morning-crowd.png" alt="saturday-morning-crowd" />
<em>早上入場還算順暢，但是場內的攤位已經需要排隊了</em></p>

<p>至於從賽道的回程，因為沒辦法預估什麼時候能到車站，所以沒有預訂特急車票，而是到車站後搭急行（不要選到普通車，等同於台灣的區間車，會站站停）。比賽日離場的人很多，因此等待接駁車的時間會很久。我這次買在 A2 席，所以可以在排位賽跟正賽結束的時候，早一點到接駁車的乘車處，但週日還是等了 1 小時多，想當然如果更晚離開就得要等更久，我在比賽日這兩天還可以回到名古屋吃晚餐。至於週四賽道日則是在正門搭乘接駁車，人不多也不用等待，只是下午 1 點才有回程的接駁車。</p>

<p>回程的時間是這樣：</p>

<table>
  <thead>
    <tr>
      <th>時間</th>
      <th>離場</th>
      <th>抵達乘車處</th>
      <th>接駁車上車</th>
      <th>抵達白子</th>
      <th>上火車</th>
      <th>抵達名古屋</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>週六</td>
      <td>16:00</td>
      <td>16:25</td>
      <td>16:50</td>
      <td>17:10</td>
      <td>17:28</td>
      <td>18:23</td>
    </tr>
    <tr>
      <td>週日</td>
      <td>15:40</td>
      <td>16:15</td>
      <td>17:30</td>
      <td>17:50</td>
      <td>18:14</td>
      <td>19:10</td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/returning-crowd.png" alt="returning-crowd" />
<img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/waiting-line.png" alt="waiting-line" />
<em>比賽日回程的人潮很恐怖，聽說有些人不想等車，直接徒步回白子車站</em></p>

<h2 id="飲食">飲食</h2>

<p>賽道園區內會有賣食物與飲料的攤販，只是價格會比較高，而且品質不穩定。可以事先採買好午餐、零食、飲料，再帶到園區內，現場也不時可以看到有人提著一袋食物入場。但如果想要吃點鹹的熱的，還是可以到攤販區逛一下，只是要找到好吃的得碰運氣。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/normal-bentou.png" alt="normal-bentou" />
<em>因為嘴饞買了這個 1200 日元的便當，但不好吃QQ</em></p>

<h2 id="總結">總結</h2>

<p>這篇文章除了記錄這次的行程規劃之外，如果之後要再次衝現地的話，也可以作為改善行程的參考，也希望這篇文章能幫助到有需要的人。這趟旅程也是做好行前準備，才能在比賽週好好體驗賽道慶典，留下很棒的回憶。</p>

<p><img src="/assets/images/blog/2025/2025-05-03-f1-japan-grand-prix-trip-planning/sakura.png" alt="sakura" />
<em>賽道也種植許多櫻花，看比賽與看櫻花一次滿足</em></p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="遊記" /><summary type="html"><![CDATA[自 2020 年入坑以來，看 F1 也進入第 6 年了。大概從前年萌生到現場看比賽的念頭，也看了一些現場觀賽的分享文後，毅然決然選定了今年的日本大獎賽。選擇日本場的原因除了日本旅遊環境友善之外，比賽舉辦的時間剛好落在清明連假，賽道當地的鈴鹿與鄰近的名古屋也是櫻花季的時期，因此這趟現地之旅就成行了。受惠於前人的分享文，所以這篇文章也來分享如何規劃行程。]]></summary></entry><entry><title type="html">[電影] 2024 看過的那些電影們</title><link href="https://lankudot.airfishlab.com/blog/2025-03-watched-movies-in-2024/" rel="alternate" type="text/html" title="[電影] 2024 看過的那些電影們" /><published>2025-03-30T00:00:00+08:00</published><updated>2025-03-30T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/watched-movies-in-2024</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2025-03-watched-movies-in-2024/"><![CDATA[<p>去年因為工作變得比較繁重，所以電影看的不多，不過這樣反而可以寫得比較詳細。為了篇幅，就簡單分成真人電影與動畫電影兩篇，這篇就記錄真人電影的部份。去年最喜歡的電影就是《沙丘：第二部》了，去二刷的時候還選了 IMAX 的版本，對於太空科幻的題材真的愛不釋手啊。</p>

<h2 id="沙丘第二部">沙丘：第二部</h2>

<p><img src="/assets/images/blog/2025/2025-03-30-watched-movies-in-2024/dune-part-2-poster.png" alt="dune-part-2-poster" /></p>

<p>被哈肯能家族襲擊，失去駐地與家人的保羅．亞崔迪加入史帝加帶領的弗瑞曼人部族後，開始集結弗瑞曼人組織對抗哈肯能家族的行動。同時保羅的母親潔西嘉女士，也利用貝尼．潔瑟睿德姐妹會事先散佈的預言以及弗瑞曼人的信仰，將保羅塑造成救世主，以獲取弗瑞曼人的支持。而哈肯能家族在奪回厄拉科斯的主導權後，繼續以往的香料採收事業，但弗瑞曼人則利用遊擊戰術破壞哈肯能人的設備以干擾採收。哈肯能男派出心狠手辣的侄子菲得．羅薩，前往厄拉科斯剷除弗瑞曼人。</p>

<p>我很喜歡太空科幻中，用宗教、文化、儀式、服裝來帶出一個種族或勢力的個性與特色。像是哈肯能家族的母星羯地主星上，人民都是光頭，穿著黑色長袍，也有著獨特的歡呼手勢。為了慶祝菲得的生日，則是在鬥技場中讓他獵殺三名亞崔迪家的俘虜。再再顯示哈肯能家是邪惡的好戰勢力。不過菲得登場的這場戲，也是我喜歡的片段之一，為了還原羯地主星所在的星系的太陽是發出紅外線光，導演特別用紅外線攝影機來拍攝，讓畫面呈現都是黑白色的。相比 1984 年《沙丘魔堡》電影裡的菲得是瘋瘋巔巔的殺手，這版的菲得顯得冷酷多謀，很有反派魅力。</p>

<p>保羅與菲德的一對一最終決戰也相當精彩，沒有過份的晃動鏡頭，可以很清楚地理解發生了什麼事。看了幕後花絮知道他們都為了戲中的打鬥練習了很多，也才知道在鬥技場跟菲得打到最後的那名演員就是本片的武術指導。當然最終保羅贏得勝利，在獲得漠大的權力後，準備向宇宙的氏族宣戰，然而此舉讓卻保羅的心上人荃妮感到生氣又失望，同時保羅夢到的聖戰已經被觸發。</p>

<h2 id="gt跨界玩家">GT：跨界玩家</h2>

<p><img src="/assets/images/blog/2025/2025-03-30-watched-movies-in-2024/gran-turismo-poster.png" alt="gran-turismo-poster" /></p>

<p>《GT：跨界玩家》是真人真事改編的電影，主角揚從小就迷上《Gran Turismo》，並且夢想成為一名職業賽車手。有一天在遊戲賽道上創下的最佳記錄，讓他獲得參加由 Nissan 與遊戲開發商共同舉辦的「GT 學院」的機會。這個學院聚集了 8 位頂尖玩家，並把他們培養成職業賽車手，最後篩選出 1 位來參加他們的車隊。這對於一直被家人反對玩遊戲的揚來說，無疑是可以證明自己的機會。</p>

<p>雖然這類電影可以知道主角的結果，但是過程怎麼發展才是電影的重點，與家人的衝突、訓練的艱苦、被職業選手看輕，一再地為主角的成功加上更多的份量，也知道這結果得來不易。電影的賽車畫面也都是實車實地拍攝，就為了給觀眾最真實的比賽體驗，而故事的真人揚也在電影中擔任特技替身。比較可惜的是賽車中的畫面不夠長，經常在人物跟賽車間切換，看得不夠過癮。《Gran Turismo》也是我第一款接觸的賽車遊戲，所以得知這部電影時，就一直有興趣。但上映那時沒有時間到電影院觀看這部電影，直到在 Netflix 上架，才有機會補完，看完覺得如果當初能到電影院體驗引擎的轟隆聲，那感覺一定很棒。</p>

<h2 id="秘境探險">秘境探險</h2>

<p><img src="/assets/images/blog/2025/2025-03-30-watched-movies-in-2024/uncharted-poster.png" alt="uncharted-poster" /></p>

<p>《秘境探險》是同名遊戲的改編電影，主角奈森流著探險家的血液，原本在酒吧擔任酒保的他，遇到寶藏獵人蘇利文告訴他正在尋找埋藏的黃金，而原本的合伙人就是奈森的哥哥ー山姆。山姆在奈森小時候，為了不想被因為多次闖入博物館偷東西被關而逃離孤兒院，雖然當時約好會回來找奈森，但是這個承諾一直沒有兌現。做為幫助蘇利文，同時為了尋找哥哥山姆的下落，奈森踏上這趟尋寶旅程。</p>

<p>做為尋寶冒險電影，肯定少不了謎題、陷阱、覬覦同個寶藏的壞人與同夥的背叛。只是可惜的是，覺得這部電影對這些要素只是把它放進去，但沒有加深刻劃。劇情的走向可以猜得到，但也沒有意外的發展。像是敵人可以找到最後的埋藏點，只是因為剛好看到主角開船往那個方向移動，雖然可以合理解釋為什麼敵人可以到達那邊，但就是選了個最普通的原因。最驚喜的反而是彩蛋，像是遊戲制作公司頑皮狗的貼紙、遊戲中奈森的真人演員諾蘭也有參一腳。另外就是當主角奈森無意戴上腋下槍套背帶，成為遊戲中的造型時，更是令人興奮。</p>

<h2 id="小丑雙重瘋狂">小丑：雙重瘋狂</h2>

<p><img src="/assets/images/blog/2025/2025-03-30-watched-movies-in-2024/joker-2-poster.png" alt="joker-2-poster" /></p>

<p>原本以為作為《小丑》的續作，再加上「雙重瘋狂」的副標題，覺得這次應該是要開始讓高譚市瘋狂了，然而整部電影就只有「亞瑟」沒有「小丑」。每當你以為亞瑟要開始瘋狂、情緒要爆發的時候，亞瑟就退縮了，說其實自己沒有想要成為小丑，電影看完只留下壓抑的感受。</p>

<p>不過滿喜歡電影前半的部份，使用歌舞做為小丑的內心幻想或是情緒延續。歌曲用在美國脫口秀中由 house band 演奏的那類爵士樂，搭配戲謔的歌詞，以及一直在背景的不協調單音。雖然充滿脫口秀的那種戲謔歡樂氣氛，但不協調的單音也帶著壓抑感，彷彿說著這一切只不過是個「Joke」。但是這種穿插歌舞表演的形式到了後半反而變成一種濫用，一到需要表達內心情感的時候，就開始唱歌，反而相當破壞節奏，甚至覺得有點煩燥。不知道是不是為了配合 Lady Gaga，才用歌舞表演的形式呈現。只是具體地把情感用歌詞唱出來，反而覺得有點多此一舉，畢竟不是所有情緒表現都適合用歌舞呈現。不過在只有小丑的幾場戲中，瓦昆還是有只用演出，就把小丑的內心狀態直接帶給觀眾，當下覺得瓦昆的演技真的很厲害。</p>

<p>從劇情來看，這版的小丑不會是以往大家對小丑的印象，雖然看起來是還想要有續集，但是亞瑟的故事應該是到這裡為止了。如果想看小丑發揮的話，這部電影不是個好選擇。</p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="電影" /><category term="心得" /><summary type="html"><![CDATA[去年因為工作變得比較繁重，所以電影看的不多，不過這樣反而可以寫得比較詳細。為了篇幅，就簡單分成真人電影與動畫電影兩篇，這篇就記錄真人電影的部份。去年最喜歡的電影就是《沙丘：第二部》了，去二刷的時候還選了 IMAX 的版本，對於太空科幻的題材真的愛不釋手啊。]]></summary></entry><entry><title type="html">[分享] 2025 亞太遊戲高峰會 -《聖騎士之戰 -奮戰-》的全球化挑戰</title><link href="https://lankudot.airfishlab.com/blog/2025-01-2025-apgs-ggst-share/" rel="alternate" type="text/html" title="[分享] 2025 亞太遊戲高峰會 -《聖騎士之戰 -奮戰-》的全球化挑戰" /><published>2025-01-30T00:00:00+08:00</published><updated>2025-01-30T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/2025-apgs-ggst-share</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2025-01-2025-apgs-ggst-share/"><![CDATA[<p>在台北電玩展舉行期間，也會同時進行亞太遊戲高峰會。高峰會邀請遊戲業相關商業人士前來分享經驗，議題涵蓋開發、技術、行銷、社群推廣等。不過對我來說，與其說是去聽演講，不如說是粉絲見面會。而今年最有興趣的演講之一是 GGST 的製作人宮內健的分享，在這場演講中也獲益良多，所以用這篇文章來分享演講的內容。</p>

<p><img src="/assets/images/blog/2025/2025-01-30-2025-apgs-ggst-share/ggst-cover-image.jpg" alt="ggst-cover-image" /></p>

<p>製作人宮內健在這場演講中主要分享在開發《聖騎士之戰 -奮戰-》（GGST）中，為了能吸引新玩家，又要兼顧舊玩家，所做的改變以及面臨的問題。</p>

<h2 id="格鬥遊戲的困境">格鬥遊戲的困境</h2>

<p>以往格鬥遊戲給人難度很高的印象，緒如只要逮到就會被連段到底，無法反擊、招式又多又複雜、需要即時反應以應對場上情況。造成格鬥遊戲很難吸引新玩家，也有玩家年齡越來越高的趨勢。在 GGST 一次封測的問券調查中，有前作遊玩經驗的人高達約 95%，而且這當中有約 74% 是 25 歲以上的玩家，而剩下的 5% 沒玩過的人中，有約 60% 是 25 歲以下的玩家。為了能讓續作繼續下去，吸引新玩家變得很重要。</p>

<h2 id="內外在進行改變">內外在進行改變</h2>

<p>為了能夠吸引新玩家，在 GGST 的外在與內在都做了改變。外在的部份是讓遊戲畫面變得乾淨，該玩家容易搞清楚場上發生的狀況。內在則是不用連段或是必殺技就可以打出高傷或是華麗的招式，而在角色的攻略影片中也避免給連段的攻略，讓玩家覺得這種程度的控制我也可以。</p>

<p><img src="/assets/images/blog/2025/2025-01-30-2025-apgs-ggst-share/ggxrd-gameplay.png" alt="ggxrd-gameplay" />
<img src="/assets/images/blog/2025/2025-01-30-2025-apgs-ggst-share/ggst-gameplay.png" alt="ggst-gameplay" />
<em>與前作相比，GGST 的介面變得簡潔。上圖擷圖<a href="https://youtu.be/Mis6bx43XII">來源</a>，下圖擷圖<a href="https://youtu.be/Yr-PY1K0j_8">來源</a></em></p>

<!-- Courtesy of embedresponsively.com -->

<div class="responsive-video-container">
    <iframe src="https://www.youtube-nocookie.com/embed/H0ha3-S926k" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
  </div>

<p class="video-caption"><em>在官方的角色攻略影片中介紹單招及簡單的指令</em></p>

<h2 id="注重線上對戰">注重線上對戰</h2>

<p>在對戰環境上也要順應線上對戰變為主流的趨勢。日本的機廳文化較為盛行，習慣面對面的對戰，所以線下的本地對戰容易進行。但是在美國地域廣大，要進行線下對戰就得長途跋涉。在線上的部份，網路狀態好的地方也相對有優勢，但美國的網路在各地也有差別。然而玩家比較喜歡找到同樣程度的人對戰，如果對戰一面倒的話，贏家沒有成就感，輸家也會覺得遊戲太難，因而留不住玩家。因此在 GGST 中也導入 Rollback Netcode，它可以讓網路環境不好的玩家也能有順暢的遊戲體驗，在疫情期間舉辦的線上賽也獲得好評。</p>

<!-- Courtesy of embedresponsively.com -->

<div class="responsive-video-container">
    <iframe src="https://www.youtube-nocookie.com/embed/7yVrUcav6DI" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
  </div>

<p class="video-caption"><em>Rollback Netcode 在收到下個指令之前，先假設玩家沒有改變輸入的指令，直到收到下個指令。如果跟預測一樣，就不改變角色的行為，如果不一樣，則柔順地將角色轉到對應的動作。避免以往沒收到指令角色就不動作所造成的卡頓感</em></p>

<h2 id="現代化的角色形象">現代化的角色形象</h2>

<p>再來就是角色外觀的喜好也在改變，而且歐美人覺得美少女互歐是一件很奇怪的事情。因此在 GGST 中讓角色的視覺形象現代化，只保留覺得「很酷」的元素，也在角色年齡與服裝上做改變。而在劇情中加入對應的故事，讓角色的改變合理化。</p>

<p><img src="/assets/images/blog/2025/2025-01-30-2025-apgs-ggst-share/may-appearance-changing.png" alt="may-appearance-changing" />
<img src="/assets/images/blog/2025/2025-01-30-2025-apgs-ggst-share/dizzy-appearance-changing.png" alt="dizzy_appearance-changing" />
<em>可以看到 May 與 Dizzy 這兩個角色在前作 GGXrd 與續作 GGST 的形象改變，服裝也以日常服為為主，但還是保留主要元素</em></p>

<h2 id="與老玩家溝通">與老玩家溝通</h2>

<p>但這些改動可能會違背老玩家想要的內容，老玩家因自己喜歡的遊戲元素被去除了而反彈，造成遊戲評價下降。所以在遊戲開發階段就開始傳達想要改變的消息，透過官網（<a href="https://www.guiltygear.com/ggst/en/news/post-category/column/">開發者後花園</a>）、社群平台、媒體等管道來發佈創作意圖與未來方針。並利用問卷調查與 beta 測試，來與玩家共同討論意見，並且會公布調查結果與開發者意見。</p>

<h2 id="消費者鴻溝">消費者鴻溝</h2>

<p>他們在問卷調查中也發現了「消費者鴻溝」（<a href="https://www.business-to-you.com/crossing-the-chasm-technology-adoption-life-cycle/">The Chasm</a>）的現象。消費者對新產品的消費習慣可以分成五個族群，這邊用遊戲做為例子：</p>

<ul>
  <li>創新者（Innovators）：只要是新遊戲就一定會玩，而且會是遊戲的改進來源</li>
  <li>早期採用者（Early Adopters）：與創新者類似，但他們會依賴自己的直覺來挑選遊戲，通常也不太在意價格，而且很樂意作為其它消費者的參考對象</li>
  <li>早期大眾（Early Majority）：不會立刻玩新遊戲，而且會參考其它人的意見來決定要不要玩這款遊戲</li>
  <li>晚期大眾（Late Majority）：等遊戲有穩定評價以及價格符合期望時，才會決定玩這款遊戲</li>
  <li>落後者（Laggards）：完全不會玩新遊戲的人</li>
</ul>

<p><img src="/assets/images/blog/2025/2025-01-30-2025-apgs-ggst-share/the-chasm.png" alt="the-chasm" /></p>

<p>這些族群的人數分佈呈現常態分佈，但是可以看到早期採用者與早期大眾之間有一個間隔，被稱為「消費者鴻溝」。這是因為早期採用者的意見會成為早期大眾的參考，如果早期採用者給出負評的話，早期大眾就不會購買這款遊戲，進而流失這部份的客群。</p>

<h2 id="總結">總結</h2>

<p>因此能在開發階段主動取得玩家的意見，對於開發方向有很大的幫助。在幾次的 beta 測試中，問卷的滿意程度也大幅提升。相比前作只有 26% 的 25 歲以下的玩家，在 GGST 中則達到 72%，讓 GGST 成為 ARC System Works 第一款擁有 300 萬玩家的格鬥遊戲，成功留下系列作玩家，也吸引了新玩家。該遊戲也在 2021 年的 TGA 中獲得最佳格鬥遊戲的獎項。</p>

<p>製作人最後提到，雖然成功模式不能直接複製，但是如果可以帶來幫助的話是再好也不過。</p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="分享" /><summary type="html"><![CDATA[在台北電玩展舉行期間，也會同時進行亞太遊戲高峰會。高峰會邀請遊戲業相關商業人士前來分享經驗，議題涵蓋開發、技術、行銷、社群推廣等。不過對我來說，與其說是去聽演講，不如說是粉絲見面會。而今年最有興趣的演講之一是 GGST 的製作人宮內健的分享，在這場演講中也獲益良多，所以用這篇文章來分享演講的內容。]]></summary></entry><entry><title type="html">[雜談] 理想與現實：大公司的價值觀洗禮</title><link href="https://lankudot.airfishlab.com/blog/2024-12-work-experience-in-big-company/" rel="alternate" type="text/html" title="[雜談] 理想與現實：大公司的價值觀洗禮" /><published>2024-12-02T00:00:00+08:00</published><updated>2024-12-02T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/work-experience-in-big-company</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2024-12-work-experience-in-big-company/"><![CDATA[<p>之前工作參與的專案規模不大，或是能切分出互不影響的功能，讓每個人各自負責，所以程式功能只要顧好自己的部份就好。在進入大公司後，專案規模變大，開發勢必得要多人一起進行。然而一人開發與多人開發的情景完全不同，大公司專案專注的面向也不一樣，理所當然，就面臨了不少價值觀的衝擊。</p>

<p><img src="/assets/images/blog/2024/2024-12-02-work-experience-in-big-company/ideal-vs-reality.png" alt="ideal-vs-reality" /></p>

<h2 id="程式風格混亂">程式風格混亂</h2>

<p>起初專案並沒有明確規範程式風格，也沒有進行 code review，造成專案中充斥著不同的程式風格。然而專案為了方便維護程式碼，即使那個是不好的風格，還是被要求跟著該功能既有的程式風格撰寫程式。</p>

<p>剛加入專案那時，一直苦惱縮排到底是用 tab 還是 space，一行 200 字元的程式碼要不要幫忙換行，或是巢狀階層多到可以打波動拳了，要不要拆出函式等。起先在加新功能的時候，我會順手改掉原本程式碼中不好的風格。但後來被阻止了，原因是如果該功能出錯，會找最後一個改動的人負責任。直到這個問題變成技術債之後，專案才開始重視程式風格，慢慢明確規範程式寫法。想想如果當初在修改前，先跟主管提出程式風格的問題的話，應該可以提前重視這個問題。</p>

<p><img src="/assets/images/blog/2024/2024-12-02-work-experience-in-big-company/choose-between-tab-and-space.png" alt="choose-between-tab-and-space" />
<em>程式碼風格不一致讓人無所適從</em></p>

<p>在多人開發專案中，能有統一的程式風格相當重要，即使那個功能不是自己開發的，也能快速理解功用。另外現今編輯器可以設定程式風格的檢查，包含強制換行、變數命名格式、縮排、行尾空白等。更嚴格一點還可以搭配 git hook，只要不合規範，就不能推上去。</p>

<h2 id="功能先有最重要">功能先有最重要</h2>

<p>因為專案的性質，需要定期推出新功能，因此功能能否即時上線是最重要的，程式碼寫得好不好並不重視。加上能開發的時間不足，為了追趕時程，也為了不影響既有的功能，只能省略架構設計，直接參考既有的程式碼撰寫，或甚至直接複製一份出來改，最慘的是連驗證的時間都不足。雖然功能即時上線了，但品質卻脆弱不堪。</p>

<p>用這個方式開發的後果就是增加後續維護的難度。同一個功能被複製了好幾份，修了其中一份的 bug 後，才發現其他地方還有相同的 bug。或是要更新某個功能時，得要找出所有複製出來的功能一併修改。為了追趕一個又一個的上線時程，這樣的技術債只會越堆越高。現在省下來的時間，後來就加倍還回去了。</p>

<p><img src="/assets/images/blog/2024/2024-12-02-work-experience-in-big-company/lot-of-bug-because-of-no-time.png" alt="lot-of-bug-because-of-no-time" />
<em>趕時間開發的功能最後帶來解不完的 bug</em></p>

<p>理想的開發模式是先規劃好功能需要哪些元件，元件之間要如何互動，再去撰寫程式碼。如果是在既有功能上製作，則要再加上理解原本架構的部份。然而要能執行這樣的開發模式，除了得有足夠的開發時間，更重要的是要有健康的專案架構。但現實是專案過了好幾手之後，功能相互交雜，牽一髮而動全身。為了避免擴大麻煩，繞過原本的功能去做新功能反而是最保險的作法。</p>

<h2 id="重構永遠是最後選項">重構永遠是最後選項</h2>

<p>開發新功能時，原有的架構不敷需求的話，就一定需要重構，然而對上線的功能來說「能動的就不要動」，要重構就得要冒著既有功能壞掉的風險。當開發與驗證時間不足的時候，想要重構也無能為力，就會出現前面所說的，只能繞路或是擱置問題。</p>

<p>只是當技術債累積到不得不面對的程度，就還是得進行重構。在參與專案的期間負責過兩次大型重構，當時各花兩個月在上面：一次是因為某個底層功能太複雜，以致於影響執行效能；另一次是幾個重要機制被複製了數次，為了讓即將開發的新功能也能使用那些機制，與後續方便維護，把它們整理出來，作為共用功能。</p>

<p><img src="/assets/images/blog/2024/2024-12-02-work-experience-in-big-company/code-debt.png" alt="code-debt" />
<em>技術債終究是要還的</em></p>

<p>無論重構規模的大小，只要有重構就得驗證所有相關的功能是否正常。重構前先確認影響的範圍，如果影響範圍太大，就得思考拆分重構的規模，一次只重構一部分。好處是容易掌握需要驗證的功能，出 bug 時容易找到出問題的地方。另外重構時，通常專案也在開發，能儘早把重構後的功能合併回專案的話，也能避免該功能仍然以舊方法開發，造成還要再度重構。</p>

<h2 id="還是有收穫">還是有收穫</h2>

<p>不過參與大公司的專案可以體驗到單人專案無法體驗的事情，其中之一是可以跟其它程式交流。當不知道功能如何設計比較好時，就可以詢問其它程式的意見，往往會得到不錯的想法。另外 code review 也是很適合交換意見的時候，除了可以分享自己的做法與建議之外，也可以看到其它人的思維，做為未來寫程式時的參考。</p>

<p>另外一個就是可以訓練溝通能力。在多人專案中，當遇到不是自己做的功能，就得要詢問當初做或比較熟那個功能的人。雖然可以靠自己閱讀程式碼來理解，但如果先問相關的程式碼與執行流程，反而更能快速上手，也更能專注在要實作的功能上。反之亦然，其它人也會來問自己做的功能，能夠清楚地解釋自己的程式碼，也是很實用的能力。</p>

<p><img src="/assets/images/blog/2024/2024-12-02-work-experience-in-big-company/conversation.png" alt="conversation" />
<em>能學習跟其它人溝通是最大的收獲</em></p>

<p>除了跟程式討論之外，也會時常跟不同部門的人討論。對方詢問問題時，得先釐清真正想問的內容，最好是能將自己理解的問題內容講給對方聽，確認理解的是不是一樣的。另一方面，也盡量以對方能理解的方式講解。否則很常雞同鴨講，最後搞得雙方都很混亂。</p>

<h2 id="生於憂患">生於憂患</h2>

<p>總覺得在體驗過什麼是不好的之後，才知道什麼是好的。在這段時間中，確實是挺煎熬的過程，但也是在這樣環境中才開始思考為什麼這樣的情況是不好的，以及如何改善這樣的情況。如果能帶到下一個可以發揮的環境的話，會是很好的養份。</p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="雜談" /><summary type="html"><![CDATA[之前工作參與的專案規模不大，或是能切分出互不影響的功能，讓每個人各自負責，所以程式功能只要顧好自己的部份就好。在進入大公司後，專案規模變大，開發勢必得要多人一起進行。然而一人開發與多人開發的情景完全不同，大公司專案專注的面向也不一樣，理所當然，就面臨了不少價值觀的衝擊。]]></summary></entry><entry><title type="html">[遊記] 來去逛逛 2024 BitSummit</title><link href="https://lankudot.airfishlab.com/blog/2024-08-visit-bitsummit/" rel="alternate" type="text/html" title="[遊記] 來去逛逛 2024 BitSummit" /><published>2024-08-03T00:00:00+08:00</published><updated>2024-08-03T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/visit-bitsummit</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2024-08-visit-bitsummit/"><![CDATA[<p>去年 9 月逛了東京電玩展之後，就決定今年要來日本最大的獨立遊戲展ーBitSummit。BitSummit 每年夏天固定在京都市勸業館舉辦，為期三天，吸引世界各地的開發者與發行商來參加。而今年舉辦在 7/19 ~ 7/21（第一天為商務日），副標題為「Drift」。</p>

<p><img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/cover-image.jpg" alt="cover-image" /></p>

<p>勸業館地點就位在平安神宮附近，搭公車就可以抵達。一般入場票為 2000 日圓，門票在一般公開日的這兩天都可以入場，要事先在網路上購票，再到日本的 7-11 請店員把票券印出來，而現場也有販售當日門票。參觀時間從早上 10 點到下午 5 點，以體驗來說算是相當超值。這次會場在場館的一樓與三樓，一樓攤位有合作夥伴、學校、桌遊、Game Jam 發表等，而三樓攤位則有主舞台、開發者、發行商等。這次跟同行友人主要目標就是三樓的攤位。</p>

<p><img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/torii-gate.jpg" alt="torii-gate" />
<em>搭公車的話，就會看到平安神宮的巨大鳥居</em></p>

<p>來現場的好處一個是可以先玩到還沒發售的遊戲，另一個就是可以跟開發者交流了。交流語言的話，體感英文 7 成，日文 3 成，當然也有會中文的開發者。話題的部份，可以聊聊遊戲開發了多久、用什麼遊戲引擎開發、當初是怎麼開始的等，或是自己喜歡遊戲的哪個部份或機制，開發者都很樂意分享自己的經驗，或是接受玩家的意見。我在這過程中，才後悔自己的英文能力怎麼那麼差，不能順利表達自己有多喜歡他們的遊戲，這次回來要多多加強口說能力了:laughing:。</p>

<p><img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/motionrec-1.jpg" alt="motionrec-1" />
<img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/motionrec-2.jpg" alt="motionrec-2" />
<em>這次在會場先玩到一直有在關注的《MOTIONREC》</em></p>

<p>這兩天下來，也試玩了十幾款遊戲，因為個人喜好大多是解謎類的遊戲。像是以錄製角色移動路徑，再播放路徑讓角色移動到原本無法到達的地方的<a href="https://store.steampowered.com/app/2602230/MOTIONREC/" target="_blank">《MOTIONREC》</a>。自己是顆易碎的蛋，要怎麼安全地跳到高處，或是下降到低處的<a href="https://store.steampowered.com/app/2617090/Fowl_Damage/" target="_blank">《Fowl Damage》</a>。還有非常喜歡日本工學院專門學校蒲田校的遊戲設計科的兩款遊戲：一個是結合倉庫番與光與影，透過移動箱子與光源，利用箱子的陰影在上方形成平台，讓影之貓可以抵達目標門的<a href="https://www.youtube.com/watch?v=fafYsxdEn04" target="_blank">《迷暗》</a>。另一個是透過複製一部份區域，來取代另一部份區域，以開啟不能通過的地方的<a href="https://www.youtube.com/watch?v=nKVWYKYurAc" target="_blank">《うつルーム》</a>。同行友人與開發者聊過之後，才知道他們是直接以 C++ 寫成遊戲，物理碰撞也都是自己寫的，真心佩服。</p>

<p><img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/miann.jpg" alt="miann" />
<img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/utsu-room.jpg" alt="utsu-room" />
<em>由學生製作的《迷暗》與《うつルーム》除了機制很吸引人之外，關卡設計也很用心</em></p>

<p>會場空間不會太擁擠，在開發者區就算兩側有人排隊，中間還是有足夠空間讓一個人通過，整天逛下來很舒服。而且很多攤位有準備二台以上的試玩設備，所以如果當下想玩的遊戲需要等待的話，先去逛其它攤位再回來都還有機會玩到。另外在一樓入場後，會拿到一個主辦發的提袋，最大可以裝下 A4 L 夾，拿來裝各家文宣相當方便，不用擔心折到，也可以不用在試玩時，煩惱要如何暫放文宣品。比較可惜的是，現場並沒有宣傳袋子中有可以拿來投最喜歡遊戲的貼紙，位在三樓的投票板上的貼紙數很少，而且如果直接到三樓會場的話，也不會拿到袋子。開發《迷暗》的學生說如果有拿到人氣獎的話，就有機會出版了，感到有點可惜。</p>

<p><img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/nice-bag.jpg" alt="nice-bag" /></p>

<p>最後飲食的部份，在一樓會場內有食物攤，會場外也有餐車，附近只有一間小小的全家。午餐時間人很多，在外面排食物也很熱。如果本來就打算一整天就在會場，建議事先就買好午餐跟飲料。</p>

<p><img src="/assets/images/blog/2024/2024-08-03-visit-bitsummit/heian-shrine.jpg" alt="heian-shrine" />
<em>BitSummit 逛完不妨到平安神宮參拜</em></p>

<p>喜歡獨立遊戲的話，BitSummit 非常值得來逛一次，可以感受到來自世界各地的開發者的熱情，很有「祭典」的氛圍。會後也公布了 2025 年的 BitSummit 在 7/18 ~ 7/20 舉辦，副標題為「XIII」，也呼應下一次是第十三屆。而這時間也恰逢日本三大祭之一「祇園祭」的期間，有機會的話，不妨安排一趟京都之旅。</p>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">HOT NEWS (literally)<br /><br />BitSummit XIII⛩️<br />July 18, 19, 20, 2025<br /><br />SAVE THE DATES! <br /><br />SEE YOU NEXT YEAR EVERYONE &lt;3 <a href="https://t.co/1JnvSuTwxI">pic.twitter.com/1JnvSuTwxI</a></p>&mdash; BitSummit (@BitSummit) <a href="https://twitter.com/BitSummit/status/1814944601741939104?ref_src=twsrc%5Etfw">July 21, 2024</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="遊記" /><category term="遊戲展" /><summary type="html"><![CDATA[去年 9 月逛了東京電玩展之後，就決定今年要來日本最大的獨立遊戲展ーBitSummit。BitSummit 每年夏天固定在京都市勸業館舉辦，為期三天，吸引世界各地的開發者與發行商來參加。而今年舉辦在 7/19 ~ 7/21（第一天為商務日），副標題為「Drift」。]]></summary></entry><entry><title type="html">[閱讀] 布莉琪．柯林斯《裝幀師》</title><link href="https://lankudot.airfishlab.com/blog/2024-07-the-binding/" rel="alternate" type="text/html" title="[閱讀] 布莉琪．柯林斯《裝幀師》" /><published>2024-07-07T00:00:00+08:00</published><updated>2024-07-07T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/the-binding</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2024-07-the-binding/"><![CDATA[<p>當回憶可以被「裝幀」到書中，自此忘卻這段痛苦的經歷，從而開始新的人生，對一個人來說或許是救贖。但如果被有心人用來裝幀受害者的回憶，抑或是這些不想記起的回憶成為收藏家的玩物時，這童話故事般的能力對被裝幀的人來說是慈悲與救贖，還是自私與痛苦。</p>

<p><img src="/assets/images/blog/2024/2024-07-07-the-binding/cover-image.jpg" alt="cover-image" /></p>

<p>主角艾墨特天生擁有裝幀師的能力，但是生長的地方卻把書視為詛咒之物，碰到書只有挨打的份。然而艾墨特生了一場重病，才發現患有「裝幀師熱」，家人在萬般不願意之下，只能將他送到裝幀所當學老裝幀師ー瑟芮狄絲ー的學徒。雖然艾墨特在成為學徒後，症狀逐漸改善，瑟芮狄絲卻遲遲不教導他關於「裝幀」的技術。隨著日子推移，艾墨特發病時會夢到的景象也越來越清晰，然而卻發現這個夢似乎是解答自己遭遇的關鍵，這背後隱藏著更大的事件。</p>

<p>一個故事讓人想要繼續閱讀，就是因為有許多問號等著解答。在知道解答時，會有種「原來是這樣啊」的感覺，但《裝幀師》在解答問題的時候，則是讓人有「什麼！居然是這樣」的感覺。意識到原來前面只知道真相的一半，對劇情的認知是錯的，每個人物看似平常的行為，其實背後都是有原因的。當初進入解答的篇章時，還一直來回對照前面的劇情，看得速度也越來越快，就是希望快點知道整個事件的全貌。</p>

<p>《裝幀師》故事分成三個篇章，鋪陳與事件篇、解答篇、解決篇，個人覺得解答篇是全書的高潮，但進入解答篇之前放的劇情高點更是畫龍點睛，從這裡才意識到「有什麼認真的要來了」。而解決篇也很有趣，是從另一個人的觀點繼續把故事延續下去，同時也在收束前面的伏筆。在看之前，原本以為《裝幀師》是奇幻故事，看了才發現是一個充滿人心黑暗的故事。</p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="閱讀" /><category term="心得" /><summary type="html"><![CDATA[當回憶可以被「裝幀」到書中，自此忘卻這段痛苦的經歷，從而開始新的人生，對一個人來說或許是救贖。但如果被有心人用來裝幀受害者的回憶，抑或是這些不想記起的回憶成為收藏家的玩物時，這童話故事般的能力對被裝幀的人來說是慈悲與救贖，還是自私與痛苦。]]></summary></entry><entry><title type="html">[Unity] 事件訂閱與問題（下）- C# 介面</title><link href="https://lankudot.airfishlab.com/blog/2024-04-unity-event-subscription-and-problem-2/" rel="alternate" type="text/html" title="[Unity] 事件訂閱與問題（下）- C# 介面" /><published>2024-04-13T00:00:00+08:00</published><updated>2024-04-13T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/unity-event-subscription-and-problem-2</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2024-04-unity-event-subscription-and-problem-2/"><![CDATA[<p>本篇繼續<a href="/blog/2024-04-unity-event-subscription-and-problem-1/">上一篇</a>的內容來介紹第三種事件訂閱的方式：C# 介面。並在最後比較這三種訂閱方式。</p>

<h2 id="c-介面">C# 介面</h2>

<p>使用 C# 介面讓物件提供事件的處理函式，並把物件註冊到事件系統上以訂閱事件。在 Unity 的 <code class="language-plaintext highlighter-rouge">EventSystems</code> 中就是使用 C# 介面讓物件訂閱操作事件。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">UIPuzzleImage</span> <span class="p">:</span> <span class="n">MonoBehaviour</span><span class="p">,</span>
    <span class="n">IBeginDragHandler</span><span class="p">,</span> <span class="n">IDragHandler</span><span class="p">,</span> <span class="n">IEndDragHandler</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">OnBeginDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnBeginDrag"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">OnDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnDrag"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">OnEndDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnEndDrag"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="實作事件系統">實作事件系統</h3>

<p>使用 C# 介面做為事件訂閱的方式，還需要自行管理訂閱的物件，以觸發事件。這邊使用 <code class="language-plaintext highlighter-rouge">HashSet</code> 來儲存訂閱的物件，好處是就算物件重複訂閱，在 <code class="language-plaintext highlighter-rouge">HashSet</code> 中也不會出現兩個物件。而且如果有需要，還可以先檢查該物件有沒有先訂閱了，而輸出警告訊息甚至是 exception。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">ILevelEventHandler</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">OnLevelStart</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">LevelManager</span> <span class="n">Instance</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">readonly</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">ILevelEventHandler</span><span class="p">&gt;</span> <span class="n">_levelEventHandlers</span> <span class="p">=</span> <span class="k">new</span> <span class="p">();</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Instance</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">SubscribeLevelEvent</span><span class="p">(</span><span class="n">ILevelEventHandler</span> <span class="n">handler</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 也可不檢查</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_levelEventHandlers</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="n">handler</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">handler</span><span class="p">}</span><span class="s"> 已經被註冊過了"</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">_levelEventHandlers</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">UnsubscribeLevelEvent</span><span class="p">(</span><span class="n">ILevelEventHandler</span> <span class="n">handler</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_levelEventHandlers</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">LevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">handler</span> <span class="k">in</span> <span class="n">_levelEventHandlers</span><span class="p">)</span>
            <span class="n">handler</span><span class="p">.</span><span class="nf">OnLevelStart</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>而用 C# 介面訂閱事件的優點是不能用匿名函式訂閱事件，一定要是物件中明確實作的函式。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span> <span class="p">:</span> <span class="n">MonoBehaviour</span><span class="p">,</span> <span class="n">ILevelEventHandler</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">SubscribeLevelEvent</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnDestory</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">UnsubscribeLevelEvent</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 明確介面實作，讓事件函式只能透過 ILevelEventHandler 介面呼叫</span>
    <span class="k">void</span> <span class="n">ILevelEventHandler</span><span class="p">.</span><span class="nf">OnLevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="c-介面的問題">C# 介面的問題</h3>

<h4 id="讓訂閱物件提供過多的-public-函式">讓訂閱物件提供過多的 <code class="language-plaintext highlighter-rouge">public</code> 函式</h4>

<p>會發現使用介面可能會讓物件提供過多的 <code class="language-plaintext highlighter-rouge">public</code> 函式，但是可以透過明確介面實作，讓實作的介面函式，只能透過介面型別呼叫。要注意在明確介面實作中，實作的函式是沒有 <code class="language-plaintext highlighter-rouge">public</code> 的。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">UIPuzzleImage</span> <span class="p">:</span> <span class="n">MonoBehaviour</span><span class="p">,</span>
    <span class="n">IBeginDragHandler</span><span class="p">,</span> <span class="n">IDragHandler</span><span class="p">,</span> <span class="n">IEndDragHandler</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="n">IBeginDragHandler</span><span class="p">.</span><span class="nf">OnBeginDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnBeginDrag"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="n">IDragHandler</span><span class="p">.</span><span class="nf">OnDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnDrag"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="n">IEndDragHandler</span><span class="p">.</span><span class="nf">OnEndDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnEndDrag"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">SomeClass</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
    <span class="k">private</span> <span class="n">UIPuzzleImage</span> <span class="n">_puzzleImage</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">SomeFunc</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Error</span>
        <span class="c1">//_puzzleImage.OnDrag(null);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="事件觸發測試">事件觸發測試</h2>

<p>以下在 Unity 中，以生成 1000 個物件測試觸發事件時的秏時。測試方式為一次觸發事件 10 次，取平均運行時間。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">StopWatch</span> <span class="n">_stopWatch</span> <span class="p">=</span> <span class="k">new</span> <span class="p">();</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">InvokeEvent</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">ticks</span> <span class="p">=</span> <span class="m">0L</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_stopWatch</span><span class="p">.</span><span class="nf">Restart</span><span class="p">();</span>
        <span class="c1">// 如果是 C# 介面則用 foreach 去逐個觸發事件</span>
        <span class="n">_onEvent</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">();</span>
        <span class="n">_stopWatch</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>
        <span class="n">ticks</span> <span class="p">+=</span> <span class="n">_stopWatch</span><span class="p">.</span><span class="n">ElapsedTicks</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">ticks</span> <span class="p">/</span> <span class="m">10f</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>而首次執行中，因為 JIT 編譯器要轉換 IL 成可執行的機器碼，所以會比較花時間，因此分別列出：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">[在編輯器]<br />首次執行</th>
      <th style="text-align: center">[在編輯器]<br />首次之後</th>
      <th style="text-align: center">[執行檔]<br />首次執行</th>
      <th style="text-align: center">[執行檔]<br />首次之後</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">UnityEvent</code></td>
      <td style="text-align: center">257.7 ticks</td>
      <td style="text-align: center">175.5 ticks</td>
      <td style="text-align: center">248.4 ticks</td>
      <td style="text-align: center">153.4 ticks</td>
    </tr>
    <tr>
      <td style="text-align: center">C# <code class="language-plaintext highlighter-rouge">event</code></td>
      <td style="text-align: center">127.3 ticks</td>
      <td style="text-align: center">31.2 ticks</td>
      <td style="text-align: center">194.2 ticks</td>
      <td style="text-align: center">28.7 ticks</td>
    </tr>
    <tr>
      <td style="text-align: center">C# 介面</td>
      <td style="text-align: center">150.9 ticks</td>
      <td style="text-align: center">35.1 ticks</td>
      <td style="text-align: center">260 ticks</td>
      <td style="text-align: center">32.9 ticks</td>
    </tr>
  </tbody>
</table>

<p>可以發現除了在執行檔中，第一次執行時，C# 介面會比較慢之外，執行的速度由快到慢為：C# <code class="language-plaintext highlighter-rouge">event</code>、C# 介面、<code class="language-plaintext highlighter-rouge">UnityEvent</code>。</p>

<h2 id="總結">總結</h2>

<p>整理這三種訂閱事件方式的問題比較表：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">過多<br /><code class="language-plaintext highlighter-rouge">public</code> 函式</th>
      <th style="text-align: center">被外部<br />觸發事件</th>
      <th style="text-align: center">重複訂閱</th>
      <th style="text-align: center">註冊<br />匿名函式</th>
      <th style="text-align: center">處理速度</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">UnityEvent</code></td>
      <td style="text-align: center">會</td>
      <td style="text-align: center">僅 <code class="language-plaintext highlighter-rouge">public</code></td>
      <td style="text-align: center">可</td>
      <td style="text-align: center">可</td>
      <td style="text-align: center">慢</td>
    </tr>
    <tr>
      <td style="text-align: center">C# <code class="language-plaintext highlighter-rouge">event</code></td>
      <td style="text-align: center">不會</td>
      <td style="text-align: center">不可</td>
      <td style="text-align: center">可</td>
      <td style="text-align: center">可</td>
      <td style="text-align: center">快</td>
    </tr>
    <tr>
      <td style="text-align: center">C# 介面</td>
      <td style="text-align: center">會，可避免</td>
      <td style="text-align: center">僅 <code class="language-plaintext highlighter-rouge">public</code></td>
      <td style="text-align: center">不可</td>
      <td style="text-align: center">不可</td>
      <td style="text-align: center">次快</td>
    </tr>
  </tbody>
</table>

<p>Unity 事件訂閱方式有各自的好處，但相對的也有各自的問題。如果沒注意事件訂閱的管理的話，只要遊戲規模一大，就很容易出問題，而且還很難找出原因。而在這三種方法中，我會推薦使用 C# 介面做為事件訂閱的方法，因為相比其它兩種方式比較不容易出錯。而且追蹤有訂閱的物件也方便，只要找出有實作該介面的類別就可以了。</p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="筆記" /><category term="Unity" /><category term="C#" /><summary type="html"><![CDATA[本篇繼續上一篇的內容來介紹第三種事件訂閱的方式：C# 介面。並在最後比較這三種訂閱方式。]]></summary></entry><entry><title type="html">[Unity] 事件訂閱與問題（上）- `UnityEvent` 與 C# `event`</title><link href="https://lankudot.airfishlab.com/blog/2024-04-unity-event-subscription-and-problem-1/" rel="alternate" type="text/html" title="[Unity] 事件訂閱與問題（上）- `UnityEvent` 與 C# `event`" /><published>2024-04-08T00:00:00+08:00</published><updated>2024-04-08T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/unity-event-subscription-and-problem-1</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2024-04-unity-event-subscription-and-problem-1/"><![CDATA[<p>在遊戲開發中，一個物件經常需要訂閱另一個物件的事件，以在事件發生時，執行對應的動作，像是玩家輸入、觸發機關、關卡管理等。而在 Unity 中，常見的方式是使用 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 與 C# <code class="language-plaintext highlighter-rouge">event</code> 來讓物件提供事件介面，讓其它物件訂閱，但這兩者各自問題，反而讓程式容易出錯。本篇文章整理 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 與 C# <code class="language-plaintext highlighter-rouge">event</code>，並講解可能的問題，而下篇則會介紹利用 C# 介面做為事件介面的第三種方式。</p>

<h2 id="unityevent"><code class="language-plaintext highlighter-rouge">UnityEvent</code></h2>

<p><code class="language-plaintext highlighter-rouge">UnityEvent</code> 在 Unity 中是最常見的訂閱事件方法，好處是讓其它物件可以在 inspector 上直接設定事件的處理函式（event handler）。通常在設計套件時，會經常使用 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 來讓使用者可以從介面設定處理函式，但這也是 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 的唯一好處了。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
    <span class="k">private</span> <span class="n">UnityEvent</span> <span class="n">_onLevelStart</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="unityevent-的問題"><code class="language-plaintext highlighter-rouge">UnityEvent</code> 的問題</h3>

<h4 id="讓訂閱的物件提供過多的-public-函式">讓訂閱的物件提供過多的 <code class="language-plaintext highlighter-rouge">public</code> 函式</h4>

<p>使用 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 的一個大問題就是想要訂閱事件的物件得要提供 <code class="language-plaintext highlighter-rouge">public</code> 函式才能在 inspector 中設置處理函式，這會讓其它物件也有機會去呼叫這個處理函式。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">OnLevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>例如：敵人物件為了在 inspector 上能訂閱關卡開始的事件，就得要提供一個 <code class="language-plaintext highlighter-rouge">public</code> 的函式，這讓其它有參考這個敵人的物件也有機會呼叫 <code class="language-plaintext highlighter-rouge">OnLevelStart</code>。</p>

<p>而且如果該物件需要接入不同的事件時，這些 <code class="language-plaintext highlighter-rouge">public</code> 函式就會越來越多。在寫程式時，就會多出許多不必要的候選函式，造成困擾。</p>

<h4 id="外部物件能觸發事件">外部物件能觸發事件</h4>

<p>除了透過 inspector 設置處理函式之外，通常也會讓處理函式能在程式中設置。雖然可以讓要訂閱事件的物件在自己內部訂閱，而能將處理函式設為 <code class="language-plaintext highlighter-rouge">private</code> 的，但為此將 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 設為 <code class="language-plaintext highlighter-rouge">public</code> 的話，反而會讓其它物件有機會呼叫 <code class="language-plaintext highlighter-rouge">Invoke()</code> 來觸發事件。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">LevelManager</span> <span class="n">Instance</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">UnityEvent</span> <span class="n">OnLevelStart</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Instance</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span><span class="p">.</span><span class="nf">AddListener</span><span class="p">(</span><span class="n">OnLevelStart</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnLevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">SomeObject</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">SomeFunc</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 不相關的物件可以呼叫</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>例如：為了能在程式中訂閱事件，<code class="language-plaintext highlighter-rouge">LevelManager</code> 將 <code class="language-plaintext highlighter-rouge">OnLevelStart</code> 事件設為 <code class="language-plaintext highlighter-rouge">public</code>，雖然可以讓 <code class="language-plaintext highlighter-rouge">Eneny</code> 物件在程式中訂閱事件，但可能讓其它物件不小心觸發到關卡開始的事件，造成意外的結果。</p>

<p>要避免這種情況的話，就還是把 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 物件宣告為 <code class="language-plaintext highlighter-rouge">private</code> 的，並讓物件提供訂閱事件的函式。如果還是要保留在 inspector 設置處理函式的功能，則加上 <code class="language-plaintext highlighter-rouge">SerializeField</code> 屬性。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
    <span class="k">private</span> <span class="n">UnityEvent</span> <span class="n">_onLevelStart</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">SubscribeOnLevelStart</span><span class="p">(</span><span class="n">UnityAction</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_onLevelStart</span><span class="p">.</span><span class="nf">AddListener</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">UnsubscribeOnLevelStart</span><span class="p">(</span><span class="n">UnityAction</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_onLevelStart</span><span class="p">.</span><span class="nf">RemoveListener</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="重複訂閱事件">重複訂閱事件</h4>

<p>無論是透過 inspector 還是 <code class="language-plaintext highlighter-rouge">AddListener()</code> 來訂閱事件，都有可能會重複訂閱，造成同一個事件處理函式被呼叫數次。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PlayerInputManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">PlayerInputManager</span> <span class="n">Instance</span><span class="p">;</span>

    <span class="p">[</span><span class="n">NonSerialized</span><span class="p">]</span>
    <span class="k">public</span> <span class="n">UnityEvent</span> <span class="n">OnFire</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">UnityEvent</span><span class="p">();</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Instance</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="nf">GetKeyDown</span><span class="p">(</span><span class="n">KeyCode</span><span class="p">.</span><span class="n">F</span><span class="p">))</span>
            <span class="n">OnFire</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Player</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">PlayerInputManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnFire</span><span class="p">.</span><span class="nf">AddListener</span><span class="p">(</span><span class="n">OnPlayerFire</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Init</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 重複訂閱</span>
        <span class="n">PlayerInputManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnFire</span><span class="p">.</span><span class="nf">AddListener</span><span class="p">(</span><span class="n">OnPlayerFire</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnPlayerFire</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnPlayerFire"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>例如：在 <code class="language-plaintext highlighter-rouge">Player</code> 物件在訂閱玩家的輸入事件時，不小心在 <code class="language-plaintext highlighter-rouge">Start()</code> 跟給外部呼叫的 <code class="language-plaintext highlighter-rouge">Init()</code> 中各訂閱一次 <code class="language-plaintext highlighter-rouge">OnFire</code> 事件，讓玩家在按下發射按鍵時，執行兩次發射行為。而且更有可能在玩家復活時，呼叫 <code class="language-plaintext highlighter-rouge">Init()</code> 來重置 <code class="language-plaintext highlighter-rouge">Player</code> 物件的狀態，造成每次復活後，會執行更多次發射行為。</p>

<h2 id="c-event">C# <code class="language-plaintext highlighter-rouge">event</code></h2>

<p>在 Unity 中，另一個訂閱事件的方式是使用 C# 的 <code class="language-plaintext highlighter-rouge">event</code>。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">LevelManager</span> <span class="n">Instance</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">event</span> <span class="n">Action</span> <span class="n">OnLevelStart</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Instance</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>C# <code class="language-plaintext highlighter-rouge">event</code> 的優點是外部物件只能訂閱事件，而無法觸發事件，只能由宣告事件的物件呼叫 <code class="language-plaintext highlighter-rouge">Invoke()</code>：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">LevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">OnLevelStart</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span> <span class="p">+=</span> <span class="n">OnLevelStart</span><span class="p">;</span>
        <span class="c1">// 無法呼叫 Invoke</span>
        <span class="c1">// LevelManager.Instance.OnLevelStart.Invoke();</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnLevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>而且比起 <code class="language-plaintext highlighter-rouge">UnityEvent</code>，C# <code class="language-plaintext highlighter-rouge">event</code> 呼叫處理函式的時間相對少很多。</p>

<h3 id="c-event-的問題">C# <code class="language-plaintext highlighter-rouge">event</code> 的問題</h3>

<h4 id="重複訂閱事件-1">重複訂閱事件</h4>

<p>不過 C# <code class="language-plaintext highlighter-rouge">event</code> 還是會發生重複訂閱事件的問題，如果同一個處理函式被重複訂閱，一樣會被呼叫數次。另一個問題是，在取消訂閱時，重複訂閱的函式只會被移除一個。但是這個情況在 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 中反而不會發生，因為呼叫 <code class="language-plaintext highlighter-rouge">RemoveListener()</code> 取消訂閱時，重複的訂閱函式都會被移除。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span> <span class="p">+=</span> <span class="n">OnLevelStart</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Init</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span> <span class="p">+=</span> <span class="n">OnLevelStart</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnDisable</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 只會移除其中一個處理函式</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span> <span class="p">-=</span> <span class="n">OnLevelStart</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnLevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>例如：<code class="language-plaintext highlighter-rouge">Enemy</code> 物件在 <code class="language-plaintext highlighter-rouge">Start()</code> 跟 <code class="language-plaintext highlighter-rouge">Init()</code> 各訂閱一次 <code class="language-plaintext highlighter-rouge">OnLevelStart</code> 事件，在 <code class="language-plaintext highlighter-rouge">OnDisable</code> 中取消訂閱時，就只會移除一個處理函式。當 <code class="language-plaintext highlighter-rouge">OnLevelStart</code> 事件觸發時，還是會看到有訊息輸出，讓原本被關閉的 <code class="language-plaintext highlighter-rouge">Enemy</code> 物件又開始執行。</p>

<h4 id="無物件訂閱">無物件訂閱</h4>

<p>在觸發 C# <code class="language-plaintext highlighter-rouge">event</code> 時，要注意如果該 event 沒有任何物件訂閱，或是因為取消訂閱到空時，此時事件物件會被設為 <code class="language-plaintext highlighter-rouge">null</code>，如果這時觸發事件會出現 null reference exception，所以最好以 <code class="language-plaintext highlighter-rouge">onEvent?.Invoke()</code> 來觸發事件。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">LevelManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">event</span> <span class="n">Action</span> <span class="n">OnLevelStart</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">LevelStart</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">OnLevelStart</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="匿名函式">匿名函式</h4>

<p>如果以匿名函式訂閱事件時，該函式就再也無法被取消訂閱了，這也會發生在 <code class="language-plaintext highlighter-rouge">UnityEvent</code> 上。因為就算內容完全一樣，在不同地方宣告的匿名函式是不同的。所以應該要避免用匿名函式訂閱事件。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Init</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span> <span class="p">+=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnDisable</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 無法取消在 Init() 訂閱的事件</span>
        <span class="n">LevelManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">OnLevelStart</span> <span class="p">-=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OnLevelStart"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>例如：敵人物件在 <code class="language-plaintext highlighter-rouge">Init()</code> 用匿名函式訂閱了 <code class="language-plaintext highlighter-rouge">OnLevelStart</code> 事件，但在 <code class="language-plaintext highlighter-rouge">OnDisable()</code> 取消訂閱時，無法移除前面用來訂閱的函式。</p>

<h2 id="小結">小結</h2>

<p>這邊小結這兩種事件訂閱方式的優點與要注意的問題：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">UnityEvent</code>
    <ul>
      <li>優點
        <ul>
          <li>可以在 inspector 中設定處理函式</li>
        </ul>
      </li>
      <li>問題
        <ul>
          <li>讓訂閱的物件提供過多的 <code class="language-plaintext highlighter-rouge">public</code> 函式</li>
          <li>外部物件能觸發事件</li>
          <li>重複註冊</li>
          <li>可以用匿名函式註冊</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>C# <code class="language-plaintext highlighter-rouge">event</code>
    <ul>
      <li>優點
        <ul>
          <li>只有宣告事件的物件才能觸發事件</li>
          <li>執行速度快</li>
        </ul>
      </li>
      <li>問題
        <ul>
          <li>重複註冊</li>
          <li>無物件訂閱時，會是 <code class="language-plaintext highlighter-rouge">null</code></li>
          <li>可以用匿名函式註冊</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="筆記" /><category term="Unity" /><category term="C#" /><summary type="html"><![CDATA[在遊戲開發中，一個物件經常需要訂閱另一個物件的事件，以在事件發生時，執行對應的動作，像是玩家輸入、觸發機關、關卡管理等。而在 Unity 中，常見的方式是使用 UnityEvent 與 C# event 來讓物件提供事件介面，讓其它物件訂閱，但這兩者各自問題，反而讓程式容易出錯。本篇文章整理 UnityEvent 與 C# event，並講解可能的問題，而下篇則會介紹利用 C# 介面做為事件介面的第三種方式。]]></summary></entry><entry><title type="html">[電影] 2023 年在家裡看過的那些電影們</title><link href="https://lankudot.airfishlab.com/blog/2024-02-watched-movies-at-home-in-2023/" rel="alternate" type="text/html" title="[電影] 2023 年在家裡看過的那些電影們" /><published>2024-02-10T00:00:00+08:00</published><updated>2024-02-10T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/watched-movies-at-home-in-2023</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2024-02-watched-movies-at-home-in-2023/"><![CDATA[<p>2023 年除了在電影院看了許多電影外，也透過 Netflix 等串流平台收看了經典以及想要補齊的電影。就用這篇來整理這段時間的心得。</p>

<h3 id="今敏的動畫電影">今敏的動畫電影</h3>

<p>前年看過《今敏：造夢魔術師》後才認識這位動畫導演，知道他的作品影響其他電影導演，可以在他們的電影中看到今敏作品的影子。看完這部紀錄片後就對他的作品非常感興趣，就下訂四部動畫電影的 BD 了，就為了能一看再看。這四部作品風格與劇情走向完全不同，但每一部內容毫不馬虎且令人印象深刻，知道他已經年紀輕輕就過世時覺得非常可惜。</p>

<p><img src="/assets/images/blog/2024/2024-02-10-watched-movies-at-home-in-2023/movie-posters-1.png" alt="movie-posters-1" /></p>

<h4 id="藍色恐懼">藍色恐懼</h4>

<p>之前就有聽說《藍色恐懼》是部心理驚悚類型的電影，對恐怖電影沒有抗性的我，真慶幸自己選早上來看這部電影。女主角未麻從偶像轉為演員後，就一直遭受未知的粉絲騷擾，另一方面又與過去的自己拉扯，逐漸對自己轉戰演員這個決定感到迷惑。電影把未知恐懼還有心理壓力營造的很好，可以感受到整部電影詭譎的氣氛。在進入解明階段後，才發現原來還有一層真相，把之前對劇情的理解完全推翻，看到這裡時感到非常驚訝。尤其電影最後未麻在車內對後照鏡講的那句話，更是耐人尋味。BD 有附錄今敏對電影的訪談，談到電影中場景隱含的未麻心理狀態。另外也一直呈現「看與被看」的關係，玻璃就是之間的界線，未麻與水族箱裡的魚、房間與窗外世界，甚至到觀眾與劇情，這也是電影中值得注意的地方。</p>

<h4 id="千年女優">千年女優</h4>

<p>《千年女優》是戲中戲類型的電影。劇中立花導演為了拍攝傳奇女星，同時也是自己的偶像—藤原千代子的紀錄片，而到她隱居的地方拜訪。電影以立花導演帶來的一把鑰匙貫穿整部劇情，就從這把鑰匙開始，回憶起過去的種種。或許千代子年紀大了，把自己的記憶跟拍攝過的電影劇情混在一起了，但沒想到的是立花導演跟他的助手也被捲入到劇情裡面了。每一段跟電影混雜在一起的回憶，千代子都在尋找當初給她這把鑰匙的那位男子，但男子同時受到壞人的追捕，每次都是立花導演扮演的角色挺身而出，排除阻礙。每一段回憶就像一個輪迴，雖然時空不同，但是主要人物與過程卻十分相似，一路從戰前到上太空，千代子總是在追尋那位男子。有時是回憶劇，有時突然來個導演喊卡，才理解這段是現實，這種似夢非夢的敘事方式，稍一不注意就會跟不上。電影結局的意涵，讓情緒完全爆發出來，最好是多準備幾張衛生紙。</p>

<h4 id="東京教父">東京教父</h4>

<p>《東京教父》充滿聖誕節奇蹟，還有如親情般的溫暖氛圍，是最適合在聖誕節看的電影之一了。三名留宿街頭的流浪漢—阿仁、小花、美由紀，在聖誕節前夕撿到一名棄嬰，因為不忍嬰兒被遺棄，於是踏上找尋其生父母的路。一路上的遭遇，逐漸道出三名流浪漢的過去，以及他們對「家庭」的價值觀與衝突。雖然他們都在冷颼颼的戶外，但越看心裡越覺得溫暖，算是今敏作品中最能直覺理解的一部了。劇情一樣毫不馬虎，每位角色的個性也很分明，當中也不乏幽默感。最喜歡流浪漢與小屁孩們打架的場景，後面辦公大樓一排房間的燈，呈現兩方的體力狀態，就跟格鬥遊戲沒兩樣。</p>

<h4 id="盜夢偵探">盜夢偵探</h4>

<p>與前面的作品不同，《盜夢偵探》就偏向科幻電影了。研究所的森啟發明的「DC 迷你」可以具現化人類的夢境，但長期使用儀器卻會使人分不清現實與夢境，而且還可以植入別人的夢境到其他使用者身上。然而研究所內的 DC 迷你被竊，主角千葉博士為了防止被拿來犯罪，開始追查兇手，甚至進入夢境中調查。很喜歡今敏能夠如此具體呈現夢境的無厘頭，像是原本看著的人，下一秒就是自己，或是跑不完的長廊，抑或是講著毫無邏輯的話，下一幕就呈現話中的場景。如果有看過《全面啟動》的話，就會發現這兩者之間有相似之處。算是四部作品中最喜歡的一部。</p>

<hr />

<p><img src="/assets/images/blog/2024/2024-02-10-watched-movies-at-home-in-2023/movie-posters-2.png" alt="movie-posters-2" /></p>

<h3 id="亨利休格的神奇故事">亨利．休格的神奇故事</h3>

<p>改編自羅爾德．達爾德《亨利．休格和其他六人的精彩故事》，由魏斯．安德森導演的喜劇電影，在 Netflix 上映書中的四個故事《亨利．休格的神奇故事》、《殺鼠之鼠》、《心腹之毒》、《天鵝之翼》。魏斯．安德森是我喜歡的導演之一，他的風格強烈，場景對稱、用色鮮明、角色演出方式，讓他的作品有「魏式美學」之稱。這系列的作品的特色是角色在做事的同時也會講出他正在作的事，或是在講完別人會做的事後，那個角色做出對應的行為，就像口述影像。有時其他角色還會疑惑地看著正在講故事的角色，想著這個人在幹嘛。另外有趣的是，角色幾乎一直面對觀眾，但透過站位來表達之間的關係。而場景佈景就像舞台劇機關，隨著劇情推進，佈景會被移出移入，也會有小幫手幫忙佈置前景道具。雖然是看影像，但感覺是在看一本立體有聲書，這就是魏斯．安德森的作品吸引人的地方。</p>

<h3 id="玩命再劫">玩命再劫</h3>

<p>《玩命再劫》（Baby Driver）的主角 Baby 是搶罪集團的車手，負責接應做案同夥到現場與逃離追捕。主角因為小時候耳朵受過傷，所以經常帶著 iPod 聽音樂以抑制耳鳴聲，而他聽的音樂就會是那一段的背景音樂。看《玩命再劫》最過癮的就是每個動作場景都有對上音樂的鼓點，不僅僅只有演員的動作，連跟週遭物件的互動也都會對上音樂。像是電影開場的搶案，一開始還以為只有主角去對上正在聽的音樂，再看一次才發現同夥開門、拿東西的動作也有對上節拍，甚至飆車經過柱子的風切聲也配合著鼓點。還有主角買咖啡回程的路上經過的塗鴉是在聽得歌曲的歌詞。我很喜歡電影中透過小動作來傳達主角的個性，像是主角對殺人感到害怕，所以開場同夥舉槍對人時，還緊張地把墨鏡拿下來看。執導的 Edger Wright 也是我喜歡的導演，他的《血與冰淇淋三部曲》與《歪小子史考特》也在我最喜歡的電影名單中，尤其是《歪小子史考特》是必看電影之一。</p>

<h3 id="終極警探">終極警探</h3>

<p>「Yippee ki-yay, MDFK.」在朋友強力推薦下，在聖誕節看了這部經典的聖誕節電影。主角紐約警探約翰．麥克連為了挽回與妻子霍莉逐漸殊遠的關係，趁聖誕節假期到洛杉機，前往妻子任職的公司所舉辦的晚宴探望她。卻沒想到中途一群武裝恐怖份子闖入公司，為了取得數億元債券劫持所有人。然而約翰趁亂逃離現場，開始個個擊倒這群恐佈份子。這部電影令我驚訝的地方就是整個劇情的時間跨度就只有一個晚上，卻毫無冷場。約翰的獨自對抗、恐怖份子的無情、媒體的噬血、當地警方的無能，每一方的對比明顯，整場就看著約翰如何支身對抗敵人。開頭那一句就是約翰對恐怖份子說的經典台詞。當時的英雄動作片流行是像史特龍那樣的肌肉男主角，但主演這部電影的布魯斯．威利反而沒有如此壯碩，卻呈現出「是一個遇到極端險境而誕生的平凡英雄」。另外沒有想到飾演恐怖份子首腦的演員是艾倫．瑞克曼，也就是在哈利波特飾演石內卜的演員，在《終極警探》中完全認不出這是他年輕的樣子。</p>

<hr />

<p><img src="/assets/images/blog/2024/2024-02-10-watched-movies-at-home-in-2023/movie-posters-3.png" alt="movie-posters-3" /></p>

<h3 id="醉好的時光">醉好的時光</h3>

<p>在《死亡擱淺》深深地被麥叔的氣質給吸引後，就一直很想補他有演出的電影，《醉好的時光》就在我的片單中。電影裡四位學校老師在學校遭遇挫折，被評論教課無趣。於是嘗試實驗透過控制血液中的酒精濃度，來驗證在微醉的狀態下，表現反而會更好的理論。在之前看到麥叔的訪談影片中，他提到為了讓表演更真實，演員們還事先舉辦體驗營，錄下自己真的喝醉時的表現作為參考。乍聽之下是喜劇電影，但更深的是中年不被認同的危機感，到後段進入爛醉實驗階段後，情況反而急轉直下，甚至當中有人無法自拔而發生悲劇，越感沈重。電影結尾麥叔邊跳著舞邊與慶祝畢業的高中生喝酒的一鏡到底的片段，搭配著 Scarlet Pleasure 的《What A Life》，是電影的經典一段。只是最後看到這一段時，不知道自己是該高興還是該哀傷。</p>

<h3 id="極地">極地</h3>

<p>在《極地》中，麥叔釋演一名過著退休生活的殺手，但前雇主找來一群年輕的殺手來斬草除根。麥叔這邊的劇情用沉穩、色調偏暗的風格進行，讓人覺得他是一位資歷豐富的殺手；而年輕殺手的劇情則是使用節奏強烈的音樂、嘻鬧、色調明亮的風格進行，呈現出他們的自信與自大。但這兩者間直接切換讓情緒不能連貫，就好像乘著一台車，原本在公路上穩穩地開著，忽然間大甩尾，接著開始飆山路，過一陣子又跑回公路上，乘客也只能暈車了。不過在這當中，看著麥叔的演技是很令人享受，舉手投足間就可以感受到角色的氣場。</p>

<hr />

<p><img src="/assets/images/blog/2024/2024-02-10-watched-movies-at-home-in-2023/movie-posters-4.png" alt="movie-posters-4" /></p>

<h3 id="全面啟動">全面啟動</h3>

<p>老實說我到 2023 年才接觸到諾蘭導演的作品，但是在這之前就大概知道《全面啟動》的故事，還有經典的轉陀螺的橋段。《全面啟動》劇情讓人回味無窮，為了讓雇主能在商業競爭中得利，雇用了一群可以進入別人夢中的主角群，利用夢來修改目標的記憶，迫使他放棄事業。過程中也一點一滴的帶出主角的過去，而個人覺得這才是電影的主軸。另外世界觀也引人入勝，「盜夢者」可以進入別人的夢中竊取資訊，所以理所當然有人為了防止侵入，會透過訓練潛意識來陪養軍隊以對付這類人。而盜夢者為了讓自己可以分辦是現實還是別人假造的夢，也會隨身攜帶作為「Token」的物品，只有自己知道它的觸感、大小等資訊，就是為了防止別人在夢中假造一樣的物品，來誤認自己是在現實，李奧納多釋演的柯布的 token 就是小陀螺。另外夢境可以由淺層進入到深層的設定也很有趣，當然進入的越深風險也越高。</p>

<h3 id="星際效應">星際效應</h3>

<p>《星際效應》是我最喜歡的科幻電影之一了。地球的農作物因為氣候變遷與病害的關係，產量越來越少，原本為太空人的主角庫柏被迫成為農夫，來幫助解決糧食問題。然而在家中的女兒墨菲發現書櫃的書會無故落下，沙塵暴在地上留下二進制座標的奇怪現象，引導庫柏到 NASA 的秘密基地。在那邊的負責人布蘭德教授說，在土星也有觀測到蟲洞，認為這是外星生命對地球發出的信號，指引人類到外太空生活。於事庫柏答應教授，與組員一同前往探索。即然是太空科幻電影，外太空的景緻肯定不能馬忽，尤其是就近到黑洞時，再配上漢斯．季默的配樂，完全能感受到黑洞的壯闊感。電影到了後段也解開為何庫柏與墨菲會遇到那些奇怪的現象，並不是單單為了推進劇情而設的橋段，同時也把劇情昇華到另一個層次，可以體會到諾蘭兄弟厲害的編劇功力。</p>

<h3 id="記憶拼圖">記憶拼圖</h3>

<p>《記憶拼圖》的主角藍納因為被歹徒襲擊而失去了妻子，同時也患上了「順行性失憶症」，之後的記憶只能持續幾分鐘，因而無法有新的記憶。所以藍納為了找出犯案的歹徒，除了在身上刺青之外，也用照片記錄人事物，並做下筆記來讓未來的自己能有行動的依據。這部電影同時帶有順敘與倒敘的時間線，我看到一半才意識到，原來黑白畫面是順敘，是從較早的時間點開始；彩色畫面是倒敘，是從後來的時間點開始，一段一段的回到之前的時間點。讓我感到厲害的是倒敘的處理方式，雖然是從後來的時間點往回敘事，但是每段都能帶來完整的資訊，而不是只留下謎題。而看了下一段後，對於上一段的理解又不一樣了，會有個「什麼，居然是這樣啊！」的感覺。而電影最後這兩條時間線交集在一起，同時也是真相大白的時候，當下只有震驚與讚嘆。</p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="電影" /><category term="心得" /><summary type="html"><![CDATA[2023 年除了在電影院看了許多電影外，也透過 Netflix 等串流平台收看了經典以及想要補齊的電影。就用這篇來整理這段時間的心得。]]></summary></entry><entry><title type="html">[電影] 2023 年進電影院看過的那些電影們</title><link href="https://lankudot.airfishlab.com/blog/2024-01-watched-movies-in-theater-in-2023/" rel="alternate" type="text/html" title="[電影] 2023 年進電影院看過的那些電影們" /><published>2024-01-28T00:00:00+08:00</published><updated>2024-01-28T00:00:00+08:00</updated><id>https://lankudot.airfishlab.com/blog/watched-movies-in-theater-in-2023</id><content type="html" xml:base="https://lankudot.airfishlab.com/blog/2024-01-watched-movies-in-theater-in-2023/"><![CDATA[<p>回想去年看的電影比起以往還要來得多，沒想到也漸漸喜歡看電影的感覺。就想來記錄去年看過的電影，以後也可以回味喜歡的作品。</p>

<p><img src="/assets/images/blog/2024/2024-01-28-watched-movies-in-theater-in-2023/movie-posters-1.png" alt="" /></p>

<h3 id="捍衛任務-4">捍衛任務 4</h3>

<p>這系列從第 1 集看到第 3 集，也終於迎來結局。最喜歡在廢棄房屋中，以 top-down 視角拍攝的戰鬥場景。流暢的運鏡，搭配龍息霰彈擊發時噴射出來的火焰，從上方看著 John Wick 從一個房間打到另一個房間，視覺一大滿足。另外沒想到飾演先驅者的 Clancy Brown，就是《刺激 1995》的警備隊長，兩者之間的氣場完全不一樣。可惜看得出基哥體力不如以前，肢體打鬥顯得單調。劇情上越來越多過場角色，防彈西裝也人人都有。而且這系列對上的主要敵人最後都讓人感覺只是個小屁孩。</p>

<h3 id="龍與地下城盜賊榮耀">龍與地下城：盜賊榮耀</h3>

<p>2023 年最喜歡的電影就是這一部了！整部電影就像是在跑團，演員們在開拍前還跟導演跑過一場 D&amp;D 來加深對角色的印象。雖然有玩過 TRPG，但沒有跑過 D&amp;D 系統，但同行的朋友說，電影中的場所、怪物、法術完全是 D&amp;D 裡面的設定。所有角色中最喜歡 Doric，可以算是整個冒險的 MVP 了，能變形成各種生物，變大可以擊退敵人，變小則可以潛入，而且演員也很可愛。電影中有一段逃離追擊的過程，看著 Doric 流暢地變形成各種不同的生物來躲避攻擊、穿越障礙，讓人感到非常過癮。</p>

<h3 id="超級瑪利歐兄弟電影版">超級瑪利歐兄弟電影版</h3>

<p>偏粉絲向的作品，看到熟悉的場景出現，像是開頭的 World 1-1、對上 Donkey Kong 的名星大亂鬥場地、瑪利歐賽車等，就比較不會在意劇情不通順了。還蠻喜歡開場設定瑪利歐跟路易吉在現實世界只是普通的水電工，還得要拍廣告來招攬生意（這一段廣告做的很棒），好不容易接到生意，卻又花式搞雜。</p>

<hr />

<p><img src="/assets/images/blog/2024/2024-01-28-watched-movies-in-theater-in-2023/movie-posters-2.png" alt="" /></p>

<h3 id="blue-giant">Blue Giant</h3>

<p>身為爵士樂的喜好者，當然是不能錯過這部以爵士樂為主題的動畫電影。當初日本在 2 月上映時，就很期望台灣也能上映，看到消息真的非常高興。在上映前，Spotify 上的原聲帶早以聽了無數次，上原廣美的編曲實在迷人。電影開場第一首 Impression 出來時，眼淚就忍不住掉下來了，果然在有好的電影院設備聽爵士樂是一大享受。雖然演奏的演出是用 3D 呈現，會讓人有點出戲，而且比較沒有力量，但我想這是為了演奏到位而做的取捨。不過最後玉田有一段鼓的 solo 完全是手繪，就可以完全感受到演奏的張力，看完又哭了一次。劇場版也補足原作漫畫劇情的缺憾，是我第二部 2023 年最喜歡的電影。</p>

<h3 id="印第安納瓊斯命運輪盤">印第安納瓊斯：命運輪盤</h3>

<p>老實說我就是為了麥叔而去看這一部電影，整場也只有麥叔的演出吸引人，把身為物理學家，醉心於穿越時空的神物發揮的淋漓盡致。最喜歡麥叔在二戰戰場剛登場時，還有最後在機場整隊準備回到過去時這兩個場景，散發出身為主要敵人的強大氣場。相比之下，劇情非常無趣，電影中三段你追我跑的情節，過程相似，只是場景不同。敵人手下的手段也相當粗糙，遇到阻礙、不合意的人就只會開槍。更遑論有些角色在劇情中可有可無。</p>

<h3 id="不可能的任務致命清算-第一章">不可能的任務：致命清算 第一章</h3>

<p>看到阿湯哥在電影中一樣生龍活虎，只能佩服再佩服了。相比之前，本集就直接進入事件核心，動作場景也多了很多，簡單來說就是部爽片。因為預告就有介紹躍下懸崖的特技是怎麼執行的，所以在看這一段時，反而可以注意觀察視覺特效是怎麼處理這個場景。對於上集角色再次登場感到驚訝，再加上這集的女主角，實在佩服阿湯哥的選角眼光。</p>

<hr />

<p><img src="/assets/images/blog/2024/2024-01-28-watched-movies-in-theater-in-2023/movie-posters-3.png" alt="" /></p>

<h3 id="奧本海默">奧本海默</h3>

<p>第一次看 IMAX 的體驗就給了奧本海默，沒想到 IMAX 的螢幕這麼大，太晚買票只能座前排的我，整場電影脖子撐得很痠。當時諾蘭的作品還沒看過很多，中場才意識到黑白畫面是之後的時間點，彩色畫面則是現在的時間點。所以前面這兩者的穿插，讓我有點跟不上劇情，但發覺這一點之後，就跟上劇情的發展了。二戰當時除了軍備競賽之外，還包含了共產主義的盛行，電影完整呈現這兩者。電影中奧本海默在原子彈一步一步完成的過程中，僅管興奮，更多的是問自己做出這個武器是否是正確的。最後在原子彈完成後的慶功演說中，對比參與人員的歡慶，只有奧本海默感受到原子彈爆炸的強光，在離場時踩到焦黑的屍體，這個橋段的象徵不言而喻，也是我覺得最棒的一段。</p>

<h3 id="拿破崙">拿破崙</h3>

<p>歷史故事也是我喜歡的題材之一，預告出來後就很期待進電影院觀賞。雖然觀影前就有看到一些評論，但是秉持著對於歷史的喜愛，還是堅持去看。沒想到法國大革命後還有這麼精彩的歷史。開場就是瑪麗皇后上斷頭台，確立拿破崙能力的土倫圍城戰，在霧月政變後如何稱帝，後面當然就是耳熟能詳的法俄戰爭與滑鐵盧戰爭。沒想到可以在兩小時半的電影中，演出這麼豐富的歷史過程。在觀影後，完全激起我對這段歷史的興趣，到 wiki 查了跟拿破崙有關的歷史，並對照電影中不同的地方。整部電影的戰爭場面做的很棒，用心在戰法與佈陣上。後來才知道飾演約瑟芬的是 Vanessa Kirby，在《不可能的任務》中飾演白寡婦，難怪覺得很熟悉。</p>

<h3 id="旺卡">旺卡</h3>

<p>適合闔家觀賞的聖誕節電影，沒想到會是像迪士尼電影那樣，在劇情中穿插歌舞的形式。電影算是《歡樂糖果屋》的前傳，也就是威利旺卡建立巧克力工廠之前的故事，其中有很多《歡樂糖果屋》的彩蛋，連歐帕倫普人的造型也是一樣的。因為是闔家觀賞的電影，所以反派的行為會比較溫合，而且受到報應時通常很滑稽，但我很喜歡這種幽默的設計。電影歌舞中，也最喜歡反派在賄賂警長這一首。這部電影對我來說算是倒吃甘蔗，前半場節奏偏慢，差點撐不下去，但在事件開始後逐漸好轉，最後抵擋不住淚腺攻擊。</p>

<hr />

<p><img src="/assets/images/blog/2024/2024-01-28-watched-movies-in-theater-in-2023/movie-posters-4.png" alt="" /></p>

<h3 id="王立宇宙軍-歐尼亞米斯之翼">王立宇宙軍 ～歐尼亞米斯之翼～</h3>

<p>當初聽聞這部動畫電影主要是為了炫技而製作的，在劇情方面並沒有很好，就抱持著享受作畫的心情，去看這次重上電影院的《王立宇宙軍》。作畫真的非常精製，幾乎每個場景都是不同的背景，機械管線的設計也令人著迷。最終火箭發射時，全場音樂停止，因液態燃料的低溫而生成的霜片紛飛，這個場面讓人暫時忘記呼吸，劇情的不足拋之腦後。不知是不是製作年代的關係，電影內的文化、宗教、服飾設定還是偏民族感，但這也是電影的另一個看點。</p>

<h3 id="星際牛仔天國之門">星際牛仔：天國之門</h3>

<p>身為 Spike 的粉絲，看到有人在揪團包場看這部星際牛仔的電影版，理所當然立刻報了名。跟著一群星際牛仔的粉絲看電影，感受完全不同。在主角群的部份，劇情主要著重在 Spike 的身上。還蠻喜歡用蒙太奇來推進劇情的手法，像是 Spike 為了打探情報，到處問人的過程。沒有台詞，只有呈現 Spike 到不同地方跟不同人互動，從他們之間的互動就可以看出詢問的結果。搭配背景音樂，又可以同時呈現當地的文化氛圍，在《王立宇宙軍》中，也是以這樣的手法呈現警探在找尋主角下落的過程。看星際牛仔的另一個享受就是菅野洋子的音樂了，開場的 AsK DNA 配上日常畫面，立刻把人拉入電影的氛圍中。還有片尾的 Gotta knock a little harder 配上結局，只能顧好自己的淚腺了。SEE YOU SPACE COWBOY…</p>

<h3 id="歡迎來到駒田蒸餾所">歡迎來到駒田蒸餾所</h3>

<p>以威士忌為主題的動畫電影，因為是冷門題材，又是動畫電影，在上映後就把握時間買票觀看了。女主角駒田琉生繼承家族的蒸餾所後，一肩扛起整個家族的未來，研發出「若葉」這款威士忌而聲名大噪，但最終是為了能讓「獨樂」這款屬於家人的威士忌能再次誕生。劇情路線是可預期的，但我對全靠熱情與精神喊話就能成功的故事，感到這實在是太理想美好了。電影場景的原型是若鶴三郎丸蒸餾所，用 Google 街景查就可以看到電影中出現的建築。三郎丸也有出現在電影中，生產劇情中登場的兩款威士忌「獨樂」與「若葉」的募資計劃，也都是由三郎丸生產。電影比較可惜的是沒有深入介紹威士忌的製程，只在開頭以蒙太奇的方式快速帶過，比較注重在調合的部份。但也讓我對威士忌的製程產生興趣，觀影後就到 YouTube 查了許多相關的介紹。</p>]]></content><author><name>烏龜</name></author><category term="blog" /><category term="電影" /><category term="心得" /><summary type="html"><![CDATA[回想去年看的電影比起以往還要來得多，沒想到也漸漸喜歡看電影的感覺。就想來記錄去年看過的電影，以後也可以回味喜歡的作品。]]></summary></entry></feed>